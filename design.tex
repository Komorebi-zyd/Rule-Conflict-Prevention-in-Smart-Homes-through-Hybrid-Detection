\section{Design}

\subsection{Overview}
\begin{figure*}[htbp]
	\centering
	\includegraphics[width=\textwidth]{figure/overall_design.png}
	\caption{Overall Architecture of Our Approach}
	\label{overall_design}
\end{figure*}

% æˆ‘ä»¬æå‡ºäº†ä¸€ç§æ–°é¢–çš„æ··åˆæ¡†æ¶ï¼Œæ—¨åœ¨é€šè¿‡é™æ€åˆ†æä¸åŠ¨æ€ç›‘æµ‹ç›¸ç»“åˆçš„æ–¹å¼æ¥å¤„ç†æ™ºèƒ½å®¶å±…ä¸­çš„è§„åˆ™å†²çªï¼Œå¹¶åœ¨å†²çªå‘ç”Ÿå‰è‡ªåŠ¨æ‰§è¡Œå®šåˆ¶åŒ–çš„å†²çªå¤„ç†ç­–ç•¥ã€‚å¦‚å›¾ \ref{overall_design} æ‰€ç¤ºï¼Œç³»ç»Ÿåˆ†ä¸ºä¸¤ä¸ªä¸»è¦é˜¶æ®µã€‚1) é™æ€åˆ†æé˜¶æ®µï¼šç³»ç»Ÿé¦–å…ˆè§£æè‡ªåŠ¨åŒ–é…ç½®ä¸ç‰©ç†é€šé“é…ç½®ä»¥æ„å»ºè§„åˆ™æ¨¡å‹ã€‚éšåï¼Œé€šè¿‡å½¢å¼åŒ–éªŒè¯æ„å»ºâ€œè§„åˆ™äº¤äº’ä¾èµ–å›¾â€ï¼ˆRule Interaction Dependency Graph, RIDGï¼‰ã€‚æ¥ç€ï¼Œç»“åˆå®ä½“å®‰å…¨é…ç½®ï¼Œç³»ç»Ÿä» RIDG ä¸­æå–å‡ºæ½œåœ¨çš„é£é™©äº¤äº’ï¼Œå½¢æˆâ€œè§„åˆ™å†²çªä¾èµ–å›¾â€ï¼ˆRule Conflict Dependency Graph, RCDGï¼‰ï¼Œå¹¶ä¸ºæ¯ä¸ªå†²çªèŠ‚ç‚¹ç”Ÿæˆå®šåˆ¶åŒ–çš„å¤„ç†ç­–ç•¥ã€‚2) åŠ¨æ€ç›‘æµ‹ä¸å†²çªç¼“è§£é˜¶æ®µï¼šç³»ç»Ÿå®æ—¶ç›‘å¬è§„åˆ™äº‹ä»¶å¹¶å°†å…¶æ˜ å°„åˆ° RCDG çš„èŠ‚ç‚¹ä¸Šã€‚åˆ©ç”¨æ–­è¨€éªŒè¯æœºåˆ¶ï¼Œç³»ç»Ÿæ£€æµ‹å½“å‰è§¦å‘çš„è§„åˆ™æ˜¯å¦æ¿€æ´»äº†ä¾èµ–å›¾ä¸­çš„å†²çªè¾¹ã€‚ä¸€æ—¦ç¡®è®¤å†²çªå³å°†å‘ç”Ÿï¼Œè¿è¡Œæ—¶æ§åˆ¶å™¨å°†ç«‹å³æ‹¦æˆªé»˜è®¤æ“ä½œå¹¶æ‰§è¡Œé¢„è®¾çš„ç¼“è§£ç­–ç•¥ã€‚\\

We propose a novel hybrid framework designed to handle rule conflicts in the smart home through a combination of static analysis and dynamic monitoring, automatically executing customized handling strategies before the conflict manifests. As shown in Figure~\ref{overall_design}, the system is divided into two main phases. 1) Static Analysis Phase: The system first parses the automation configuration and physical channel configuration to construct the rule model. Subsequently, it builds the Rule Interaction Dependency Graph (RIDG) through formal verification. Next, by incorporating the entity security configuration, the system extracts potentially risky interactions from the RIDG, forming the Rule Conflict Dependency Graph (RCDG), and generates a customized handling strategy for each conflict node. 2) Dynamic Monitoring and Conflict Mitigation Phase: The system monitors rule events in real-time and maps them to the nodes of the RCDG. Utilizing the assertion verification mechanism, the system detects whether the currently triggered rule has activated a conflict edge in the dependency graph. Once the impending conflict is confirmed, the runtime controller immediately intercepts the default operation and executes the pre-defined conflict mitigation strategy.

\subsection{Static Analysis}

% åœ¨ä»‹ç»é™æ€é˜¶æ®µä¹‹å‰ï¼Œé¦–å…ˆé˜è¿°æœ¬æ–¹æ¡ˆå¯¹è§„åˆ™äº¤äº’ä¸è§„åˆ™å†²çªçš„åˆ†ç±»æ–¹æ³•ã€‚åŸºäºä¹‹å‰çš„è§‚å¯Ÿï¼Œæˆ‘ä»¬é‡‡ç”¨Figure~\ref{classification_observation}çš„æ–¹å¼å°†è§„åˆ™ä¹‹é—´çš„äº¤äº’ç±»å‹å½’çº³ä¸ºä»¥ä¸‹ï¼šä¸€æ¡è§„åˆ™çš„æ‰§è¡Œç»“æœå¯¹å¦ä¸€æ¡è§„åˆ™çš„è§¦å‘å™¨ã€æ¡ä»¶æˆ–åŠ¨ä½œäº§ç”Ÿç›´æ¥æˆ–é—´æ¥çš„å½±å“ã€‚ç”±æ­¤ï¼Œæˆ‘ä»¬å°†è§„åˆ™äº¤äº’åˆ†ä¸ºä»¥ä¸‹å‡ ç±»ï¼šè§¦å‘å™¨äº¤äº’ (Trigger Interaction)ã€æ¡ä»¶äº¤äº’ (Condition Interaction)ã€åŠ¨ä½œäº¤äº’ (Action Interaction)ã€é—´æ¥è§¦å‘å™¨äº¤äº’ (Indirect Trigger Interaction)ã€é—´æ¥æ¡ä»¶äº¤äº’ (Indirect Condition Interaction) å’Œé—´æ¥åŠ¨ä½œäº¤äº’ (Indirect Action Interaction)ã€‚ç›¸åº”åœ°ï¼Œæˆ‘ä»¬å®šä¹‰äº†å…­ç§è§„åˆ™å†²çªç±»å‹ï¼šè§¦å‘å™¨å†²çª (Trigger Conflict)ã€æ¡ä»¶å†²çª (Condition Conflict)ã€åŠ¨ä½œå†²çª (Action Conflict)ã€é—´æ¥è§¦å‘å™¨å†²çª (Indirect Trigger Conflict)ã€é—´æ¥æ¡ä»¶å†²çª (Indirect Condition Conflict) å’Œé—´æ¥åŠ¨ä½œå†²çª (Indirect Action Conflict)ã€‚

Before formally introducing the static phase, it is first necessary to clarify our approach to classifying rule interactions and rule conflicts. Based on previous core observations, we summarize the types of interactions between rules as shown in Figure~\ref{classification_observation}: the execution result of one rule can have direct or indirect impacts on the trigger, condition, or action attributes of another rule. Accordingly, we classify rule interactions into the following categories: Trigger Interaction, Condition Interaction, Action Interaction, Indirect Trigger Interaction, Indirect Condition Interaction, and Indirect Action Interaction. Correspondingly, we define six types of rule conflicts: Trigger Conflict, Condition Conflict, Action Conflict, Indirect Trigger Conflict, Indirect Condition Conflict, and Indirect Action Conflict.

\subsubsection{Rule Modeling}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.4\textwidth]{figure/classification_observation.png}
	\caption{Rule Interaction Pattern}
	\label{classification_observation}
\end{figure}
\textbf{}
% æ™ºèƒ½å®¶å±…è§„åˆ™é€šå¸¸ä»¥é™æ€æ–‡ä»¶å½¢å¼å­˜å‚¨ï¼Œä»ä¸­å¯ä»¥æå–è§„åˆ™çš„è§¦å‘å™¨ (T)ã€æ¡ä»¶ (C) å’ŒåŠ¨ä½œ (A) å±æ€§ï¼Œå¹¶å»ºæ¨¡ä¸ºè§¦å‘å™¨-æ¡ä»¶-åŠ¨ä½œï¼ˆTCAï¼‰æ¨¡å‹ã€‚ç„¶è€Œï¼Œæ ‡å‡†çš„ TCA æ¨¡å‹æ— æ³•æ•æ‰é€šè¿‡ç‰©ç†ç¯å¢ƒï¼ˆå³â€œä¾§ä¿¡é“â€ï¼‰äº§ç”Ÿçš„é—´æ¥äº¤äº’ï¼Œä¾‹å¦‚ä¸åŒè§„åˆ™å¯¹å§å®¤æ¸©åº¦çš„å½±å“æ‰€å¼•å‘çš„äº¤äº’ã€‚ä¸ºäº†è§£å†³è¿™ä¸€é—®é¢˜ï¼Œæˆ‘ä»¬å¼•å…¥äº†ç‰©ç†é€šé“é…ç½®ï¼ˆPhysical Channel Configurationï¼‰å¹¶æå‡ºäº†å¢å¼ºçš„ TCAE æ¨¡å‹ã€‚æˆ‘ä»¬å®šä¹‰ç‰©ç†é€šé“å±æ€§ $E=[e^1, e^2,\dots]$ï¼Œå…¶ä¸­ $e^i=(zone, channel, trend)$ã€‚$zone$ è¡¨ç¤ºå—å½±å“çš„åŒºåŸŸï¼Œå¦‚å¨æˆ¿ã€å®¢å…æˆ–æ•´ä¸ªå®¶åº­ç­‰ï¼›$channel$ è¡¨ç¤ºç‰©ç†é‡ï¼Œå¦‚æ¸©åº¦ã€æ¹¿åº¦ã€å…‰ç…§å¼ºåº¦ç­‰ï¼›$trend$ è¡¨ç¤ºå½±å“æ–¹å‘å¦‚å‡é«˜ã€é™ä½ã€‚ä¾‹å¦‚ï¼Œè‹¥ä¸€æ¡è§„åˆ™å¼€å¯å§å®¤åŠ çƒ­å™¨ï¼Œå…¶åŠ¨ä½œå±æ€§ $E_A$ å°†åŒ…å« $\langle bedroom, temperature, increase \rangle$ã€‚é€šè¿‡è¿™ç§å»ºæ¨¡ï¼Œç³»ç»Ÿèƒ½å¤Ÿè¯†åˆ«å‡ºè·¨åŒºåŸŸæˆ–åŸºäºç¯å¢ƒå˜åŒ–çš„éšå¼å…³è”ã€‚å¯¹äºè§„åˆ™çš„è§¦å‘å™¨æˆ–æ¡ä»¶ï¼Œå¦‚æœ $e$ ä¸º $\langle kitchen, temperature, increases\rangle$ï¼Œåˆ™è¡¨ç¤ºå…¶ä»–è§„åˆ™çš„æ‰§è¡Œç»“æœå¯èƒ½å¯¼è‡´å¨æˆ¿æ¸©åº¦å‡é«˜ï¼Œä»è€Œä½¿å½“å‰è§„åˆ™çš„è§¦å‘å™¨æ›´æ˜“è§¦å‘æˆ–æ¡ä»¶æ›´æ˜“æ»¡è¶³ã€‚å¯¹äºè§„åˆ™çš„åŠ¨ä½œï¼Œå¦‚æœ $e$ ä¸º $\langle kitchen, temperature, increases\rangle$ï¼Œåˆ™è¡¨ç¤ºå½“å‰è§„åˆ™çš„æ‰§è¡Œå¯èƒ½å¯¼è‡´å¨æˆ¿æ¸©åº¦å‡é«˜ã€‚å±æ€§ $E$ åŸºäºç”¨æˆ·çœŸå®çš„å®¶åº­æƒ…å†µå’Œç›¸å…³è§„åˆ™ç¡®å®šã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªå®¶åº­ä¸­æ²¡æœ‰ä»»ä½•ä¸ "æ¹¿åº¦" ç›¸å…³çš„è§„åˆ™ï¼Œåˆ™æ— éœ€å°† $channel$ è®¾ç½®ä¸º "æ¹¿åº¦"ã€‚ç”±æ­¤ï¼Œè§„åˆ™å¯ä»¥è¢«é‡æ–°å»ºæ¨¡ä¸º $R=\langle T,C,A,E\rangle $ æˆ– $R=\langle T,C,A,E_T,E_C,E_A \rangle$ å½¢å¼ã€‚

Smart home rules are typically stored in static files, from which the Trigger (T), Condition (C), and Action (A) attributes of the rule can be extracted and modeled as the Trigger-Condition-Action (TCA) model. However, the standard TCA model fails to capture indirect interactions generated through the physical environment (i.e., "side channels"), such as interactions arising from the effect of different rules on the bedroom temperature. To address this issue, we introduce the Physical Channel Configuration and propose the enhanced TCAE model. We define the physical channel attribute $E=[e^1, e^2,\dots]$, where $e^i=(zone, channel, trend)$. The $zone$ represents the affected zone, such as the kitchen, living room, or the entire home; the $channel$ represents the physical quantity, such as temperature, humidity, or light intensity; and the $trend$ represents the direction of influence, such as increase or decrease. For example, if a rule turns on the bedroom heater, its action attribute $E_A$ will contain $\langle bedroom, temperature, increase \rangle$. Through this modeling, the system can identify implicit associations across zones or those based on environmental changes. For the trigger or condition of a rule, if $e$ is $\langle kitchen, temperature, increases\rangle$, it means the execution result of other rules may cause the kitchen temperature to rise, thereby making the current rule's trigger easier to fire or its condition easier to satisfy. For a rule's trigger or condition, if $e$ is $\langle kitchen, temperature, increases\rangle$, it implies that the execution results of other rules causing the kitchen temperature to rise may facilitate the triggering of the current rule or satisfy its condition. For the action of a rule, if $e$ is $\langle kitchen, temperature, increases\rangle$, it means the execution of the current rule may cause the kitchen temperature to rise. The attribute $E$ is determined based on the user's real home setup and relevant rules. For example, if a home does not have any humidity-related rules, the $channel$ does not need to be set to "humidity." Thus, a rule can be re-modeled in the form of $R=\langle T,C,A,E\rangle $ or $R=\langle T,C,A,E_T,E_C,E_A \rangle$.

% é€šè¿‡ä»¥ä¸Šå»ºæ¨¡æ–¹å¼ï¼Œæˆ‘ä»¬å¯ä»¥æ¸…æ¥šåœ°è·å–æ¯ä¸€æ¡è‡ªåŠ¨åŒ–è§„åˆ™çš„è§¦å‘å™¨ã€æ¡ä»¶ã€åŠ¨ä½œåŠå…¶å¯¹åº”çš„ç‰©ç†é€šé“å±æ€§ï¼Œä¸ºè‡ªåŠ¨åŒ–è§„åˆ™è®¾ç½®ç¿»è¯‘æ¨¡æ¿ï¼Œä»¥Motivating Example and Problem Analysisç« èŠ‚ä¸­è®¾ç½®åœ¨greenhouseçš„ä¸¤ä¸ªè§„åˆ™ä¸ºä¾‹ï¼ŒR1é…ç½®å†…å®¹ä¸º \texttt{Rule:R1}$\langle$ \texttt{T=\{platform:input datetime, entity id:system time, event:sunset\}}, \texttt{C=\{null\}}, \texttt{A=\{platform:input boolean, entity id: heater, action:turn on\}}, \texttt{TE=\{null\}}, \texttt{CE=\{null\}}, \texttt{AE=\{greenhouse-temperature-up\}} $\rangle$ï¼Œå¯ä»¥åŸºäºæ¨¡æ¿è½¬åŒ–ä¸ºâ€œè§„åˆ™ R1 ï¼šå¦‚æœæ—¥è½ï¼Œæ‰“å¼€åŠ çƒ­å™¨ï¼Œä¼šä½¿å¾—å§å®¤æ¸©åº¦å‡é«˜â€ï¼ŒR2çš„é…ç½®å†…å®¹ä¸ºï¼š\texttt{Rule:R2} $\langle$ \texttt{T=\{platform: numeric state, entity id:temperature sensor, above:30}\},C=\{\texttt{null}\},A=\{\texttt{platform:input boolean, entity id: heater, action:turn off | platform:input boolean, entity id: skylight, action:turn on\}}, \texttt{TE=\{greenhouse-temperature-up\}}, \texttt{CE=\{null\}}, \texttt{AE=\{greenhouse-temperature-up | greenhouse-temperature-down\}} $\rangle$ï¼Œå¯ä»¥åŸºäºæ¨¡æ¿è½¬åŒ–ä¸ºâ€œè§„åˆ™ R2ï¼šå¦‚æœæ¸©åº¦ä¼ æ„Ÿå™¨é«˜äº30æ‘„æ°åº¦ï¼Œå…³é—­åŠ çƒ­å™¨ï¼Œæ‰“å¼€çª—æˆ·ï¼Œæ¸©åº¦å¯èƒ½å‡é«˜ä¹Ÿå¯èƒ½é™ä½â€ã€‚\\

Through the above modeling method, we can clearly obtain the trigger, condition, action, and corresponding physical channel attributes for each automation rule. By setting translation templates for automation rules, and taking the two rules set in the greenhouse from the Motivating Example and Problem Analysis section as examples, the configuration content for R1 is \texttt{Rule:R1}$\langle$ \texttt{T=\{platform:input datetime, entity id:system time, event:sunset\}}, \texttt{C=\{null\}}, \texttt{A=\{platform:input boolean, entity id: heater, action:turn on\}}, \texttt{TE=\{null\}}, \texttt{CE=\{null\}}, \texttt{AE=\{greenhouse-temperature-up\}} $\rangle$. Based on the template, this can be translated into: â€œRule R1: If sunset, turn on the heater, which will cause the greenhouse temperature to rise.â€ The configuration content for R2 is: \texttt{Rule:R2} $\langle$ \texttt{T=\{platform: numeric state, entity id:temperature sensor, above:30}\},C=\{\texttt{null}\},A=\{\texttt{platform:input boolean, entity id: heater, action:turn off | platform:input boolean, entity id: skylight, action:turn on\}}, \texttt{TE=\{greenhouse-temperature-up\}}, \texttt{CE=\{null\}}, \texttt{AE=\{greenhouse-temperature-up | greenhouse-temperature-down\}} $\rangle$. Based on the template, this can be translated into: â€œRule R2: If the temperature sensor is above 30 degrees Celsius, turn off the heater and turn on the skylight. The temperature may rise or fall.â€

\subsubsection{Construction of Rule Interaction Dependency Graph}

% åœ¨å®Œæˆè§„åˆ™å»ºæ¨¡åï¼Œæˆ‘ä»¬åˆ©ç”¨å½¢å¼åŒ–éªŒè¯æ–¹æ³•æ¥è¯†åˆ«æ‰€æœ‰å¯èƒ½çš„è§„åˆ™äº¤äº’æ¨¡å¼ï¼Œå¹¶ä½¿ç”¨æœ‰å‘å›¾çš„å½¢å¼è¿›è¡Œè¡¨ç¤ºã€‚é¦–å…ˆåœ¨æœ¬æ–¹æ¡ˆä¸­å¯¹äºè§„åˆ™å†²çªã€æ½œåœ¨è§„åˆ™å†²çªã€è§„åˆ™äº¤äº’ä¸‰è€…çš„å…³ç³»ä¸ºè§„åˆ™å†²çªå…³ç³»$\in$æ½œåœ¨è§„åˆ™å†²çª$\in$è§„åˆ™äº¤äº’ã€‚æˆ‘ä»¬å®šä¹‰â€œè§„åˆ™äº¤äº’ä¾èµ–å›¾â€ï¼ˆRIDGï¼‰ä¸º $G_I = (V, E_I)$ï¼Œå…¶ä¸­é¡¶ç‚¹é›† $V$ ä»£è¡¨æ‰€æœ‰çš„è‡ªåŠ¨åŒ–è§„åˆ™ï¼Œè¾¹é›† $E_I$ ä»£è¡¨è§„åˆ™é—´çš„äº¤äº’å…³ç³»ã€‚

% åŸºäºå›¾ \ref{classification_observation}ï¼Œå¦‚æœåœ¨è§„åˆ™ $R_i$ å’Œ $R_j$ ä¹‹é—´å­˜åœ¨æ»¡è¶³è¡¨ \ref{Formal_Analysis_Expression} ä¸­å®šä¹‰çš„é€»è¾‘å…³ç³»ï¼ˆä¾‹å¦‚ï¼Œ$R_i$ çš„åŠ¨ä½œ $A_i$ è§¦å‘äº† $R_j$ çš„è§¦å‘å™¨ $T_j$ï¼‰ï¼Œåˆ™åœ¨å›¾ä¸­å»ºç«‹ä¸€æ¡æœ‰å‘è¾¹ $R_i \rightarrow R_j$ã€‚å½¢å¼åŒ–éªŒè¯æ¨¡å—éå†æ‰€æœ‰è§„åˆ™å¯¹ï¼ŒéªŒè¯å…¶æ˜¯å¦æ»¡è¶³å…­ç§äº¤äº’ç±»å‹ï¼ˆè§¦å‘å™¨äº¤äº’ã€æ¡ä»¶äº¤äº’ã€åŠ¨ä½œäº¤äº’åŠå…¶å¯¹åº”çš„é—´æ¥ç±»å‹ï¼‰ã€‚æœ€ç»ˆç”Ÿæˆçš„ RIDG åŒ…å«äº†ç³»ç»Ÿå†…æ‰€æœ‰é€»è¾‘ä¸Šå’Œç‰©ç†ä¸Šå¯èƒ½çš„å…³è”ï¼Œä¸ºåç»­çš„å†²çªæ£€æµ‹æä¾›äº†å®Œæ•´çš„æœç´¢ç©ºé—´ã€‚

% å½¢å¼åŒ–éªŒè¯æ–¹æ³•å¦‚è¡¨\ref{Formal_Analysis_Expression}æ‰€ç¤ºï¼Œå‡è®¾è§„åˆ™ $R_1=\langle T_1,C_1,A_1,E_{T_1},E_{C_1},E_{A_1} \rangle$ å’Œ ğ‘…â‚‚=(ğ‘‡â‚‚, ğ¶â‚‚, ğ´â‚‚, ğ¸(ğ‘‡â‚‚), ğ¸(ğ¶â‚‚), ğ¸(ğ´â‚‚)) è¡¨ç¤ºåœ¨åŒä¸€ç³»ç»Ÿä¸­è®¾ç½®çš„ä¸¤æ¡è§„åˆ™ã€‚å…¶ä¸­ï¼ŒTã€Cã€A å’Œ E åˆ†åˆ«è¡¨ç¤ºå¯¹åº”çš„å±æ€§ã€‚ä½¿ç”¨ $\rightarrow$ è¡¨ç¤ºä¿ƒä½¿è§¦å‘å™¨è§¦å‘æˆ–æ¡ä»¶æ»¡è¶³ï¼Œ$\nrightarrow$ è¡¨ç¤ºç¦æ­¢æ¡ä»¶æ»¡è¶³ã€‚å¯¹äº channel å±æ€§ï¼Œ$\bot$ è¡¨ç¤ºä¸¤ä¸ª channel å±æ€§å…·æœ‰ç›¸åŒçš„ $zone$ å’Œ $channel$ï¼Œä½† $trend$ ç›¸åï¼ˆä¾‹å¦‚ï¼Œå¨æˆ¿æ¸©åº¦å‡é«˜ä¸å¨æˆ¿æ¸©åº¦é™ä½ï¼‰ã€‚æ­¤å¤–ï¼Œ$\bot$ ä¹Ÿè¡¨ç¤ºä¸¤ä¸ªåŠ¨ä½œç›¸äº’å†²çªï¼ˆä¾‹å¦‚ï¼Œå¼€å¯ç©ºè°ƒä¸å…³é—­ç©ºè°ƒï¼‰ã€‚"=" è¡¨ç¤ºä¸¤ä¸ª channel å±æ€§å…·æœ‰ç›¸åŒçš„ $zone$ã€$channel$ å’Œ $trend$ï¼Œæˆ–è€…ä¸¤ä¸ªè§¦å‘å™¨æˆ–æ¡ä»¶ç›¸åŒã€‚

After completing rule modeling, we utilize the formal verification method to identify all possible rule interaction patterns and represent them in the form of a directed graph. We define the Rule Interaction Dependency Graph (RIDG) as $G_I = (V, E_I)$, where the vertex set $V$ represents all automation rules, and the edge set $E_I$ represents the rule interaction relationships.

Based on Figure~\ref{classification_observation}, if a logical relationship defined in Table~\ref{Formal_Analysis_Expression} exists between rule $R_i$ and $R_j$ (e.g., the action $A_i$ of $R_i$ triggers the trigger $T_j$ of $R_j$), a directed edge $R_i \rightarrow R_j$ is established in the graph. The formal verification module iterates through all rule pairs, verifying whether they satisfy the six interaction types (Trigger Interaction, Condition Interaction, Action Interaction, and their corresponding indirect types). The resulting RIDG encompasses all logically and physically possible associations within the system, providing a complete search space for subsequent conflict detection.

The formal verification method is shown in Table~\ref{Formal_Analysis_Expression}. Assume rules $R_1=\langle T_1,C_1,A_1,E_{T_1},E_{C_1},E_{A_1} \rangle$ and $R_2=(T_2, C_2, A_2, E(T_2), E(C_2), E(A_2))$ represent two rules configured in the same system. T, C, A, and E denote the corresponding attributes. We use $\rightarrow$ to denote facilitating a trigger to fire or a condition to be met, and $\nrightarrow$ to denote prohibiting a condition from being met. For channel attributes, $\bot$ signifies that two channel attributes have the same $zone$ and $channel$ but opposite $trend$ (e.g., kitchen temperature increase versus kitchen temperature decrease). Additionally, $\bot$ also indicates that two actions conflict with each other (e.g., turning on the air conditioner versus turning off the air conditioner). "=" signifies that two channel attributes have the same $zone$, $channel$, and $trend$, or that two triggers or conditions are identical.

\begin{table*}[htbp]
	\begin{center}
		\caption{Formal Analysis Expression}
		\label{Formal_Analysis_Expression}
		\begin{adjustbox}{width=0.95\textwidth}
			\begin{tabular}[width=0.95\textwidth]{c|c}
				\hline
				\textbf{Classification} & \textbf{Expression}\\
				\hline
				\text{Trigger Interaction} & $(\exists a_{1}\in A_{1})\wedge(a_{1}\rightarrow T_{2})$ \\
				\hline
				\text{Condition Interaction} & $\left((A_{1}\nrightarrow C_{2})\wedge\left((T_{1}\neq T_{2})\wedge(R_{1}\neq R_{2})\right)\right)\vee\left((A_{1}\rightarrow C_{2})\wedge\left((T_{1}\neq T_{2})\wedge(R_{1}\neq R_{2})\right)\right)$ \\
				\hline
				\text{Action Interaction} & $(\exists a_{1}\in A_{1})\wedge(\exists a_{2}\in A_{2})\wedge(a_{1}\perp a_{2})$ \\
				\hline
				\text{Indirect Trigger Interaction} & $(\exists a_{1}\in A_{1})\wedge\left(E_{a_{1}}=E_{T_{1}}\right)$ \\
				\hline
				\text{Indirect Condition Interaction} & $\left(\left(E_{A_{1}}\perp E_{C_{2}}\right)\vee\left(E_{A_{1}}=E_{C_{2}}\right)\right)\wedge\left(R_{1}\neq R_{2}\right)$ \\
				\hline
				\text{Indirect Action Interaction} & $(\exists a_{1}\in A_{1})\wedge(\exists a_{2}\in A_{2})\wedge\left(D_{a_{1}}\neq D_{a_{2}}\right)\wedge\left(E_{a_{1}}\perp E_{a_{2}}\right)$ \\
				\hline
			\end{tabular}
		\end{adjustbox}
	\end{center}
\end{table*}

% å¯¹è§„åˆ™äº¤äº’æ¨¡å¼çš„å®šä¹‰å¯ä»¥å®ç°å¯¹è§„åˆ™äº¤äº’æè¿°çš„ç¿»è¯‘æ¨¡æ¿ï¼Œç»§ç»­ä»¥Motivating Example and Problem Analysisç« èŠ‚ä¸­è®¾ç½®åœ¨greenhouseçš„ä¸¤ä¸ªè§„åˆ™ä¸ºä¾‹ï¼Œæˆ‘ä»¬å‘ç°è‡ªåŠ¨åŒ–è§„åˆ™ R1 çš„æ‰§è¡ŒåŠ¨ä½œå¯èƒ½ä¼šå¯¼è‡´è‡ªåŠ¨åŒ–è§„åˆ™ R2 è¢«è§¦å‘ï¼Œç¬¦åˆTrigger Interactionçš„äº¤äº’æ¨¡å¼ï¼Œå› æ­¤å¯ä»¥è®¾ç½®æ¨¡æ¿ç¿»è¯‘ä¸ºï¼šâ€œè‡ªåŠ¨åŒ–è§„åˆ™ R1 çš„æ‰§è¡ŒåŠ¨ä½œä½¿å¾—æ¸©åº¦å‡é«˜ï¼Œå¯¼è‡´è‡ªåŠ¨åŒ–è§„åˆ™ R2 è¢«è§¦å‘â€

The definition of rule interaction patterns allows for the creation of translation templates for describing rule interactions. Continuing with the example of the two rules set in the greenhouse from the Motivating Example and Problem Analysis section, we find that the execution action of automation rule R1 may cause automation rule R2 to be triggered, which conforms to the Trigger Interaction pattern. Thus, a template translation can be set as: â€œThe execution action of automation rule R1 raises the temperature, leading to the triggering of automation rule R2.â€

\subsubsection{Extraction of Rule Conflict Dependency Graph}

% å¹¶éæ‰€æœ‰çš„è§„åˆ™äº¤äº’éƒ½æ˜¯æœ‰å®³çš„ã€‚ä¸ºäº†å‡å°‘è¯¯æŠ¥å¹¶è¯†åˆ«çœŸæ­£çš„â€œè§„åˆ™å†²çªâ€ï¼Œæˆ‘ä»¬å¼•å…¥äº†å®ä½“å®‰å…¨é…ç½®ï¼ˆEntity Safety Configurationï¼‰æ¥è¿‡æ»¤ RIDGã€‚æˆ‘ä»¬å°†â€œè§„åˆ™å†²çªä¾èµ–å›¾â€ï¼ˆRCDGï¼‰å®šä¹‰ä¸º RIDG çš„å­å›¾ $G_C = (V_C, E_C)$ï¼Œå…¶ä¸­ $E_C \subseteq E_I$ ä»…åŒ…å«è¿åå®‰å…¨é…ç½®çš„äº¤äº’è¾¹ã€‚å®ä½“å®‰å…¨é…ç½®æ˜¯å®‰å…¨æ•æ„Ÿè®¾å¤‡å®ä½“çš„å®‰å…¨çŠ¶æ€ä¸å±é™©çŠ¶æ€é›†åˆï¼Œç”¨äºè¡¨ç¤ºæ™ºèƒ½å®¶å±…ç³»ç»Ÿä¸­å‘ç”Ÿå†²çªæ—¶åº”ä¼˜å…ˆä¿æŒçš„çŠ¶æ€æˆ–è€…é¿å…å‘ç”Ÿçš„çŠ¶æ€ï¼Œå®ä½“å®‰å…¨é…ç½®å°†ç»“åˆIoTé¢†åŸŸçš„ç°æœ‰å®‰å…¨å±æ€§ç ”ç©¶æ•°æ®è¿›è¡Œè‡ªåŠ¨é…ç½®ï¼Œä¾‹å¦‚ï¼Œé—¨åº”ä¿æŒ "å…³é—­" çŠ¶æ€ï¼Œæ¶ˆé˜²å–·æ·‹å¤´åº”ä¿æŒ "å¯ç”¨" çŠ¶æ€ï¼ŒåŒæ—¶ç”¨æˆ·å¯ä»¥è‡ªè¡Œå®šä¹‰ï¼Œä¾‹å¦‚å¯¹äºå…·å¤‡é—ªçƒå˜è‰²åŠŸèƒ½çš„ç¯å…·ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è¯»å–è®¾å¤‡å¯é€‰æ‹©çŠ¶æ€ï¼Œå…‰æ•ç™«ç—«æ‚£è€…èƒ½å¤Ÿå°†â€œé—ªçƒå˜è‰²â€çš„çŠ¶æ€å®šä¹‰ä¸ºå¨èƒã€‚

% æˆ‘ä»¬é‡‡ç”¨åŸºäºâ€œå®‰å…¨å€¼â€ï¼ˆsafety value, $sf$ï¼‰çš„å¯å‘å¼ç®—æ³•æ¥æ„å»º RCDGã€‚å¯¹äº RIDG ä¸­çš„æ¯ä¸€æ¡è¾¹ï¼ˆå³è§„åˆ™äº¤äº’å¯¹ $R_1, R_2$ çš„äº¤äº’å…³ç³»ï¼‰ï¼Œç³»ç»Ÿè®¡ç®—è§„åˆ™æ‰§è¡Œç»“æœå¯¹å®ä½“å®‰å…¨çŠ¶æ€çš„åç¦»ç¨‹åº¦ã€‚å¦‚æœäº¤äº’å¯¼è‡´ç»“æœè¿èƒŒäº†é¦–é€‰å®‰å…¨çŠ¶æ€ï¼ˆä¾‹å¦‚ï¼Œ$sf < 0$ï¼‰æˆ–è€…å€¾å‘äºå±é™©çŠ¶æ€ï¼Œåˆ™è¯¥äº¤äº’è¢«æ ‡è®°ä¸ºâ€œæ½œåœ¨è§„åˆ™å†²çªâ€ï¼Œå¹¶ä¿ç•™åœ¨ RCDG ä¸­ï¼›å¦åˆ™ï¼Œè¯¥è¾¹è¢«å‰ªé™¤ã€‚è¿™ç§åŸºäºå›¾çš„æå–æ–¹æ³•æœ‰æ•ˆåœ°å°†å…³æ³¨ç‚¹ä»æ‰€æœ‰äº¤äº’ç¼©å°åˆ°ä»…å…·æœ‰æ½œåœ¨é£é™©çš„äº¤äº’è·¯å¾„ä¸Šã€‚ã€‚$sf$ å€¼é€šè¿‡éå†æ‰€æœ‰å®ä½“å®‰å…¨é…ç½®ï¼Œé‡‡ç”¨çº¿æ€§å‡½æ•°è®¡ç®—ã€‚ä¾‹å¦‚ï¼Œè‹¥è§„åˆ™çš„æ‰§è¡Œç»“æœæ˜¯å…³é—­é—¨ï¼Œè¿™ç¬¦åˆå®ä½“ "é—¨" çš„å®‰å…¨çŠ¶æ€ "å…³é—­"ï¼Œåˆ™è¯¥è§„åˆ™çš„ $sf$ å€¼åœ¨åŸæœ‰åŸºç¡€ä¸ŠåŠ ä¸€ï¼Œåä¹‹åˆ™å‡ä¸€ã€‚é»˜è®¤å€¼ä¸ºé›¶ã€‚

Not all rule interactions are harmful. To reduce false positives and identify genuine rule conflicts, we introduce the Entity Safety Configuration to filter the RIDG. We define the Rule Conflict Dependency Graph (RCDG) as a subgraph of the RIDG, $G_C = (V_C, E_C)$, where $E_C \subseteq E_I$ only contains interaction edges that violate the safety configuration. The entity safety configuration is a set of safe and dangerous states for safety-sensitive device entities, used to represent the states that should be prioritized or avoided when a conflict occurs in the smart home system. The entity safety configuration will be automatically configured by combining existing safety property research data in the IoT domain. For example, a door should remain "closed," and a fire sprinkler head should remain "enabled." Additionally, users can define custom configurations; for instance, for lights with flashing and color-changing capabilities, the system automatically reads the available states, and a user with photosensitive epilepsy can define the "flashing and color-changing" state as a threat.

We employ a heuristic algorithm based on safety value ($sf$) to construct the RCDG. For every edge in the RIDG (i.e., the interaction relationship of the rule pair $R_1, R_2$), the system calculates the degree of deviation of the rule execution result from the entity safe state. If the interaction leads to a result that violates the preferred safe state (e.g., $sf < 0$) or tends toward a dangerous state, the interaction is marked as a candidate rule conflict and retained in the RCDG; otherwise, the edge is pruned. This graph-based extraction method effectively narrows the focus from all interactions to only those interaction paths with potential risk. We employ a heuristic algorithm based on a ``safety score'' ($sf$) to construct the RCDG. The $sf$ value is calculated using a linear accumulation function based on the Entity Safety Configuration. For example, if the execution result of the rule is to close the door, which conforms to the safe state "closed" of the entity "door," the $sf$ value for this rule is incremented by one from its original value; conversely, it is decremented. The default value is zero.

\begin{table*}[htbp]
	\begin{center}
		\caption{Handling Strategy Decision}
		\label{Resolution_Policy_Decision}
		\begin{adjustbox}{width=0.95\textwidth}
			\begin{tabular}{c|c|c}
				\hline
				\textbf{Classification} & \textbf{Decision} & \textbf{Options} \\
				\hline
				\multirow{3}{*}{\makecell{\textbf{Trigger Conflict} \\ \textbf{Indirect Trigger Conflict}}}
				& $sf_2\geq 0$ & Not rule conflict \\
				\cline{2-3}
				& $sf_1 \geq 0 \land sf_2 < 0$ & Only execute $R_1$ \\
				\cline{2-3}
				& $sf_1 < 0 \land sf_2 < 0$ & Neither rule will be executed \\
				\hline
				\multirow{3}{*}{\makecell{\textbf{Condition Conflict} \\ \textbf{Indirect Condition Conflict}}}
				& $(A_{1}\rightarrow C_{2}\wedge sf_{2} \geq 0)\vee(A_{1}\nrightarrow C_{2}\wedge sf_{2} \leq 0)$ & Not rule conflict \\
				\cline{2-3}
				& $A_{1}\rightarrow C_{2}\wedge sf_{2}<0$ & Do not execute $R_2$\\
				\cline{2-3}
				& $(A_{1}\nrightarrow C_{2}) \wedge (sf_{2}>0) \wedge (sf_{1}<0) $ & Execute $R_2$ \\
				\hline
				\multirow{4}{*}{\makecell{\textbf{Action Conflict} \\ \textbf{Indirect Action Conflict}}}
				& $sf_1 \geq 0 \land sf_2 \geq 0$ & Not rule conflict \\
				\cline{2-3}
				& $sf_1 \geq 0 \land sf_2 < 0$ & Only execute $R_1$ \\
				\cline{2-3}
				& $sf_1 < 0 \land sf_2 \geq 0$ & Only execute $R_2$ \\
				\cline{2-3}
				& $sf_1 < 0 \land sf_2 < 0$ & Neither rule will be executed \\
				\hline
			\end{tabular}
		\end{adjustbox}
	\end{center}
\end{table*}
	
\subsubsection{Generation of Customized Handling Strategy}

% é’ˆå¯¹ RCDG ä¸­çš„æ¯ä¸€æ¡å†²çªè¾¹ï¼Œç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆå®šåˆ¶åŒ–çš„å¤„ç†ç­–ç•¥ã€‚ä¸åŒäºé€šç”¨çš„â€œå±è”½â€ç­–ç•¥ï¼Œæˆ‘ä»¬çš„æ–¹æ³•ä¾æ®è¡¨ \ref{Resolution_Policy_Decision} ä¸­çš„é€»è¾‘ï¼Œç»“åˆ $sf$ å€¼çš„å¤§å°ï¼Œæ™ºèƒ½åœ°å†³å®šæ˜¯å–æ¶ˆæŸæ¡è§„åˆ™ã€ä»…æ‰§è¡Œé«˜ä¼˜å…ˆçº§è§„åˆ™ï¼Œè¿˜æ˜¯æŒ‰ç‰¹å®šé¡ºåºæ‰§è¡Œã€‚ç”Ÿæˆçš„ç­–ç•¥å°†ä¸ RCDG ä¸€åŒä¼ é€’ç»™åŠ¨æ€ç›‘æµ‹æ¨¡å—ã€‚

% é’ˆå¯¹ä¸åŒç±»å‹çš„è§„åˆ™äº¤äº’ï¼Œè§„åˆ™å†²çªçš„åˆ¤å®šæ–¹æ³•æœ‰æ‰€ä¸åŒï¼š
% \begin{itemize}
	% 	\item å¯¹äºè§¦å‘å™¨äº¤äº’å’Œé—´æ¥è§¦å‘å™¨äº¤äº’ï¼Œå…³æ³¨ç¬¬äºŒæ¡è§„åˆ™çš„å®‰å…¨å€¼ $sf$ æ˜¯å¦å¤§äºé›¶ã€‚è‹¥å°äºé›¶ï¼Œåˆ™åˆ¤å®šä¸ºè§„åˆ™å†²çªã€‚
	% 	\item å¯¹äºæ¡ä»¶äº¤äº’å’Œé—´æ¥æ¡ä»¶äº¤äº’ï¼Œè‹¥ç¬¬ä¸€ä¸ªè§„åˆ™ç¦æ­¢äº†ç¬¬äºŒä¸ªè§„åˆ™çš„æ¡ä»¶ï¼Œä¸”ç¬¬äºŒä¸ªè§„åˆ™çš„ $sf$ å¤§äºé›¶ï¼Œåˆ™åˆ¤å®šä¸ºè§„åˆ™å†²çªï¼›åä¹‹ï¼Œè‹¥ç¬¬ä¸€ä¸ªè§„åˆ™ä½¿å¾—ç¬¬äºŒä¸ªè§„åˆ™çš„æ¡ä»¶å¾—ä»¥æ»¡è¶³ï¼Œä¸”ç¬¬äºŒä¸ªè§„åˆ™çš„ $sf$ å°äºé›¶ï¼Œä¹Ÿåˆ¤å®šä¸ºè§„åˆ™å†²çªã€‚è¿™è¡¨æ˜å‰ä¸€æ¡è§„åˆ™çš„å½±å“å¯¼è‡´åä¸€æ¡æ›´ç¬¦åˆå®ä½“å®‰å…¨çŠ¶æ€çš„è§„åˆ™æœªè¢«æ‰§è¡Œï¼Œæˆ–å¯¼è‡´åä¸€æ¡ä¸å®ä½“å®‰å…¨çŠ¶æ€ç›¸è¿èƒŒçš„è§„åˆ™è¢«æ‰§è¡Œã€‚
	% 	\item å¯¹äºåŠ¨ä½œäº¤äº’å’Œé—´æ¥åŠ¨ä½œäº¤äº’ï¼Œè‹¥å…¶ä¸­åŒ…å«çš„ä¸¤æ¡è§„åˆ™çš„å®‰å…¨å€¼ä¹‹ä¸€ä¸ä¸ºé›¶ï¼Œåˆ™åˆ¤å®šä¸ºè§„åˆ™å†²çªã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå³ä½¿ä¸¤æ¡è§„åˆ™çš„å®‰å…¨å€¼éƒ½å¤§äºé›¶ï¼Œä»å¯èƒ½åˆ¤å®šä¸ºè§„åˆ™å†²çªï¼Œå› ä¸ºæ­¤ç±»äº¤äº’ä¸­çš„ä¸¤æ¡è§„åˆ™çš„æ‰§è¡Œç»“æœæ˜¯ç›¸äº’çŸ›ç›¾çš„ï¼Œé€šå¸¸åªéœ€æ‰§è¡Œå…¶ä¸­ä¸€æ¡è§„åˆ™ã€‚
	% \end{itemize}

For every conflict edge in the RCDG, the system automatically generates a customized handling strategy. Unlike generic "blocking" policies, our method intelligently decides whether to cancel a rule, execute only the rule with higher priority, or execute them in a specific order, based on the logic in Table~\ref{Resolution_Policy_Decision} and the magnitude of the $sf$ value. The generated strategies are passed to the dynamic monitoring module along with the RCDG.

The determination of a rule conflict differs for various types of rule interaction:
\begin{itemize}
	\item For Trigger Interaction and Indirect Trigger Interaction, the focus is on whether the safety value ($sf$) of the second rule is greater than zero. If it is less than zero, it is determined to be a rule conflict.
	\item For Condition Interaction and Indirect Condition Interaction, if the first rule prohibits the condition of the second rule, and the $sf$ of the second rule is greater than zero, it is determined to be a rule conflict; conversely, if the first rule enables the condition of the second rule to be met, and the $sf$ of the second rule is less than zero, it is also determined to be a rule conflict. This indicates that the influence of the former rule either prevents a rule that conforms more closely to the entity safety state from being executed or causes a rule that contradicts the entity safety state to be executed.
	\item For Action Interaction and Indirect Action Interaction, if the safety value of one of the two involved rules is not zero, it is determined to be a rule conflict. It should be noted that even if the safety values of both rules are greater than zero, it may still be determined to be a rule conflict, as the execution results of the two rules in this type of interaction are mutually contradictory, and typically only one of them should be executed.
\end{itemize}


% ç”±æ­¤ï¼Œå¯ä»¥ä¸ºæ¯ç§è§„åˆ™å†²çªè®¾å®šå¤šç§å¤„ç†ç­–ç•¥ã€‚å…·ä½“çš„å†²çªå¤„ç†ç­–ç•¥å¯æ ¹æ® Table~\ref{Resolution_Policy_Decision} è¿›è¡Œé€‰æ‹©ã€‚

% é™¤æ­¤ä¹‹å¤–ï¼Œç³»ç»Ÿå°†ç»“åˆé€šè¿‡ç¿»è¯‘æ¨¡æ¿å°†æ‰€æœ‰çš„è§„åˆ™äº¤äº’ä¸æ½œåœ¨è§„åˆ™å†²çªã€å†²çªå¤„ç†ç­–ç•¥è½¬ä¸ºç”¨æˆ·æ˜“æ‡‚çš„è‡ªç„¶è¯­è¨€ï¼Œç”¨æˆ·å¯ä»¥ç»“åˆä¸ªäººçš„åå¥½å¯¹è§„åˆ™äº¤äº’ä¸æ½œåœ¨è§„åˆ™å†²çªè¿›è¡Œè°ƒæ•´ã€‚

Thus, multiple handling strategies can be set for each type of rule conflict. Specific conflict handling strategies can be selected according to Table~\ref{Resolution_Policy_Decision}.

In addition, the system will use translation templates to convert all rule interactions, candidate rule conflicts, and conflict handling strategies into natural language that is easy for the user to understand. Users can then adjust the rule interactions and candidate rule conflicts based on personal preferences.
\subsection{Dynamic Monitoring and Conflict Mitigation}

\subsubsection{Rule Event Listening and Graph Mapping}

% åŠ¨æ€ç›‘æµ‹çš„æ ¸å¿ƒæ€æƒ³æ˜¯å®æ—¶å…³æ³¨ç³»ç»Ÿä¸­çš„è§„åˆ™äº‹ä»¶ï¼Œä»è€Œè¿½è¸ª RCDG ä¸­çš„èŠ‚ç‚¹çŠ¶æ€ã€‚è§„åˆ™äº‹ä»¶ç›‘å¬æ¨¡å—æŒç»­æ•è·ç³»ç»Ÿä¸­çš„è§¦å‘äº‹ä»¶ã€‚å½“è§„åˆ™ $R_i$ è¢«è§¦å‘æ—¶ï¼Œç³»ç»Ÿå¹¶ä¸å­¤ç«‹åœ°çœ‹å¾…å®ƒï¼Œè€Œæ˜¯å°†å…¶è¯†åˆ«ä¸º RCDG ä¸­çš„ä¸€ä¸ªå·²è¯†åˆ«èŠ‚ç‚¹ï¼ˆIdentified Nodeï¼‰ã€‚ç³»ç»Ÿç«‹å³æ£€æŸ¥è¯¥èŠ‚ç‚¹åœ¨å›¾ä¸­æ˜¯å¦å­˜åœ¨å‡ºè¾¹ï¼ˆOutgoing Edgesï¼‰ï¼Œå³æ˜¯å¦å­˜åœ¨é‚»æ¥èŠ‚ç‚¹ï¼ˆAdjacent Nodesï¼‰ã€‚å¦‚æœä¸å­˜åœ¨é‚»æ¥èŠ‚ç‚¹ï¼Œè¯´æ˜è¯¥è§„åˆ™å½“å‰å®‰å…¨ï¼›å¦‚æœå­˜åœ¨ï¼Œåˆ™è¡¨æ˜å­˜åœ¨æ½œåœ¨çš„çº§è”å†²çªé£é™©ï¼Œéœ€è¦å¯¹ä¸¤ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„è¾¹è¿›è¡Œæ–­è¨€éªŒè¯ã€‚

% åŒæ—¶è®¾è®¡äº†èŠ‚ç‚¹é—å¿˜æœºåˆ¶ï¼Œå¦‚æœä¸€æ¡è§„åˆ™çš„æ‰§è¡ŒåŠ¨ä½œè¢«æ‰“æ–­ï¼Œä¾‹å¦‚ä¸€æ¡è§„åˆ™æ§åˆ¶ç©ºè°ƒæ‰“å¼€ï¼Œåˆ™è¯¥è§„åˆ™æˆåŠŸè§¦å‘å¹¶æ‰§è¡Œåä¼šè¢«è§†ä¸ºå·²è¯†åˆ«è‡ªåŠ¨åŒ–èŠ‚ç‚¹ï¼Œä¹‹åå¦‚æœå­˜åœ¨ç”¨æˆ·æ‰‹åŠ¨ï¼Œæˆ–è€…å…¶ä»–è§„åˆ™çš„æ‰§è¡ŒåŠ¨ä½œï¼Œæ›´æ”¹äº†è¯¥è§„åˆ™æ§åˆ¶çš„è®¾å¤‡çŠ¶æ€ï¼ˆå¦‚å°†ç©ºè°ƒå…³é—­ï¼‰ï¼Œåˆ™ä¼šå°†è¯¥è‡ªåŠ¨åŒ–è§„åˆ™èŠ‚ç‚¹é—å¿˜ã€‚

% é€šè¿‡åŠ¨æ€è¯†åˆ«èŠ‚ç‚¹ä¸é—å¿˜èŠ‚ç‚¹å®ç°å¯¹é•¿æ—¶é—´è¿è¡Œçš„æ™ºèƒ½å®¶å±…ç³»ç»Ÿè¿›è¡ŒåŠ¨æ€è·Ÿè¸ªï¼Œä¿æŒèšç„¦å¯¹å½“å‰æ­£åœ¨è¿è¡Œçš„è§„åˆ™ä»¥åŠå³å°†æ‰§è¡Œçš„è§„åˆ™

The core idea of dynamic monitoring is to focus on rule events in real-time, thereby tracking the state of nodes in the RCDG. The Rule Event Listening module continuously captures trigger events in the system. When rule $R_i$ is triggered, the system does not view it in isolation but identifies it as an Identified Node in the RCDG. The system immediately checks whether this node has outgoing edges in the graph, i.e., whether adjacent nodes exist. If no adjacent nodes exist, the rule is currently safe; if they do exist, it indicates a potential cascade conflict risk, requiring assertion verification on the edge connecting the two nodes.

A Node Forgetting Mechanism is also designed: if the execution action of a rule is interrupted (e.g., a rule controls the air conditioner to turn on), the rule, after being successfully triggered and executed, is considered an Identified Automation Node. Subsequently, if a user manually or another rule's execution action changes the state of the device controlled by this rule (e.g., turns off the air conditioner), the automation rule node will be forgotten.

Through dynamic identification of nodes and forgetting nodes, we achieve dynamic tracking of a long-running smart home system, maintaining focus on currently running rules and those about to be executed.

\subsubsection{Assertion Verification Mechanism}

% å³ä½¿åœ¨ RCDG ä¸­å­˜åœ¨è¾¹ $R_i \rightarrow R_j$ï¼Œå†²çªä¹Ÿä¸ä¸€å®šåœ¨å½“å‰æ—¶åˆ»å‘ç”Ÿï¼ˆä¾‹å¦‚ä¸¤æ¡è§„åˆ™å­¤ç«‹å‘ç”Ÿï¼Œè€Œéé€šè¿‡è§„åˆ™äº¤äº’å‘ç”Ÿï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¼•å…¥äº†æ–­è¨€éªŒè¯æœºåˆ¶ï¼ˆAssertion Verification Mechanismï¼‰æ¥è¿›è¡Œè¿è¡Œæ—¶ç¡®è®¤ã€‚

% å½“ç›‘å¬åˆ° RCDG ä¸­çš„èŠ‚ç‚¹ $R_i$ï¼Œå¦‚æœå…¶ä¸´è¾¹èŠ‚ç‚¹ $R_j$ è¢«è¯†åˆ«ä½†è¿˜æœªæ‰§è¡Œæ—¶ï¼Œç³»ç»Ÿä¼šå¯¹ä¸¤èŠ‚ç‚¹çš„è¾¹è¿›è¡Œæ–­è¨€æ£€æŸ¥ã€‚æ–­è¨€é€»è¾‘å¦‚è¡¨ \ref{Assertion_Verification} æ‰€ç¤ºã€‚æ–­è¨€éªŒè¯ä¸»è¦åŒ…å«ä»¥ä¸‹å‡½æ•°ï¼š

Even if an edge $R_i \rightarrow R_j$ exists in the RCDG, a conflict does not necessarily occur at the current moment (e.g., if the two rules fire in isolation rather than through a rule interaction). Therefore, we introduce the Assertion Verification Mechanism for runtime confirmation.

When node $R_i$ in the RCDG is monitored, if its adjacent node $R_j$ is identified but not yet executed, the system performs an assertion check on the edge between the two nodes. The assertion logic is shown in Table~\ref{Assertion_Verification}. The assertion verification primarily involves the following functions:

\begin{itemize}
	\item $obs()$: Observing the occurrence of an event (including the triggering of the trigger $obs(T)$,the passing of a condition check $obs(C)$, the failing of a condition check $obs(\neg C)$ and the execution of an action $obs(A)$
	\item $intime(X, Y, \delta)$: Returns true if the time interval between events $X$ and $Y$ is less than $\delta$ (default $\delta = 0.1s$).
\end{itemize}

% ç”±æ­¤ï¼Œé’ˆå¯¹ä¸åŒç±»å‹çš„è§„åˆ™å†²çªï¼Œå­˜åœ¨å¯¹åº”çš„æ–­è¨€éªŒè¯æ–¹æ³•ï¼Œå¦‚ Table~\ref{Assertion_Verification} æ‰€ç¤ºã€‚ åªæœ‰å½“æ–­è¨€æ¡ä»¶å…¨éƒ¨æ»¡è¶³æ—¶ï¼Œç³»ç»Ÿæ‰åˆ¤å®šâ€œæ½œåœ¨è§„åˆ™å†²çªâ€è½¬åŒ–ä¸ºâ€œå³å°†å‘ç”Ÿçš„å†²çªâ€ï¼ˆImpending Rule Conflictï¼‰ã€‚

Thus, corresponding assertion verification methods exist for different types of rule conflicts, as shown in Table~\ref{Assertion_Verification}. Only when all assertion conditions are met does the system determine that the candidate rule conflict has transformed into an Impending Rule Conflict.

\begin{table}[t]
	\caption{Assertion Verification Expression}
	\label{Assertion_Verification}
	\begin{adjustbox}{width=0.5\textwidth}
		\begin{tabular}[width=1\textwidth]{c|c|c}
			\hline
			\multicolumn{2}{c|}{\textbf{Classification}} & \textbf{Expression}\\
			\hline
			
			\multicolumn{2}{c|}{\textbf{Trigger Conflict}} &
			\makecell{
				$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(T_2), obs(C_2)$ \\
				$intime(A_1, T_2, \delta)$}\\
			\hline
			
			\multirow{2}{*}{\textbf{Condition Conflict}} & Make Conditions Forbidden &
			\makecell{$obs(C_2)$ \\
				$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(\neg C_2)$ \\
				$intime(A_1, \neg C_2, \delta)$} \\
			\cline{2-3}
			& Make Conditions Satisfied &
			\makecell{$obs(\neg C_2)$ \\
				$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(C_2)$\\
				$intime(A_1, C_2, \delta)$ }\\
			\hline
			
			\multicolumn{2}{c|}{\textbf{Action Conflict}} &
			\makecell{
				$obs(T_1), obs(C_1), obs(A_1)$
				\\ $obs(T_2), obs(C_2)$}\\
			\hline
			
			\multicolumn{2}{c|}{\textbf{Indirect Trigger Conflict}} &
			\makecell{$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(T_2), obs(C_2)$} \\
			\hline
			
			\multirow{2}{*}{\textbf{Indirect Condition Conflict}} & Make Conditions Forbidden &
			\makecell{$obs(C_2)$ \\
				$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(\neg C_2)$  \\
				$intime(A_1, \neg C_2, \delta)$ }\\
			\cline{2-3}
			& Make Conditions Satisfied &
			\makecell{$obs(\neg C_2)$ \\
				$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(C_2)$ \\
				$intime(A_1,  C_2, \delta)$ }\\
			\hline
			
			\multicolumn{2}{c|}{\textbf{Indirect Action Conflict}}&
			\makecell{$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(T_2), obs(C_2)$} \\
			\hline
			
		\end{tabular}
	\end{adjustbox}
\end{table}

% ä¾‹å¦‚å­˜åœ¨ä¸¤æ¡è§„åˆ™$R_1$å’Œ$R_2$åœ¨é™æ€æ£€æµ‹ä¸­å±äºTrigger Conoflictç±»å‹çš„è§„åˆ™å†²çªï¼Œæ–­è¨€éªŒè¯è¿‡ç¨‹å¦‚ä¸‹ï¼š(1)ç¬¬ä¸€æ­¥ï¼Œåˆ†åˆ«è§‚å¯Ÿåˆ°$T_1$ï¼Œ$C_1$å’Œ$A_1$çš„å‘ç”Ÿï¼Œè¡¨æ˜è¡¨æ˜è§„åˆ™$R_1$è§¦å‘å¹¶é€šè¿‡æ¡ä»¶æ£€æµ‹åæˆåŠŸæ‰§è¡Œé¢„æœŸåŠ¨ä½œï¼›(2)ç¬¬äºŒæ­¥ï¼Œåˆ†åˆ«è§‚å¯Ÿåˆ°$T_2$å’Œ$C_2$çš„å‘ç”Ÿï¼Œè¡¨æ˜è§„åˆ™$R_2$è§¦å‘å¹¶é€šè¿‡äº†æ¡ä»¶æ£€æµ‹ï¼Œå¹³å°åŠå°†æ‰§è¡Œ$R_2$çš„é»˜è®¤åŠ¨ä½œï¼›(3)è§‚å¯Ÿåˆ°$A_1$å’Œ$T_2$ä¸¤ä¸ªäº‹ä»¶çš„å‘ç”Ÿçš„æ—¶é—´é—´éš”å¾ˆçŸ­ï¼Œæ—¶é—´é—´éš”å°äºé˜ˆå€¼$\delta$ã€‚ä¸‰ä¸ªæ­¥éª¤å…¨éƒ¨ä¸ºçœŸåˆ™å¯ä»¥è®¤ä¸ºæ˜¯è§„åˆ™$R_1$çš„æ‰§è¡Œå¯¼è‡´äº†è§„åˆ™$R_2$è¢«è§¦å‘å¹¶å³å°†æ‰§è¡Œï¼Œä¸ºäº†é˜²æ­¢çœŸå®ä¸–ç•Œä¸­çš„å·§åˆå‘ç”Ÿï¼Œå³é¿å…æ˜¯å› ä¸ºå…¶ä»–ç°å®åŸå› è§„åˆ™$R_1$ä¸è§„åˆ™$R_2$åœ¨ç¬¦åˆç”¨æˆ·é¢„æœŸæ¡ä»¶ä¸‹åˆ†åˆ«çŸ­æ—¶é—´å†…å‡ºå‘å¹¶æ‰§è¡Œè€Œå¯¼è‡´è¯¯åˆ¤ï¼Œè¿™é‡Œçš„$\delta$é€šå¸¸è®¾ç½®å¾ˆå°çš„å€¼ï¼Œå¦‚0.1ç§’ç”šè‡³0.01ç§’ã€‚ä¸å¿…æ‹…å¿ƒå› ä¸ºç³»ç»Ÿæ‰§è¡Œæ—¶çš„å¿…ç„¶æ—¶é—´æŸè€—å¯¼è‡´é˜ˆå€¼$\delta$åå°è€Œå¼•èµ·è§„åˆ™å†²çªæ²¡æœ‰è¢«ç›‘æµ‹å‡ºï¼Œå› ä¸ºç³»ç»Ÿä¸­çš„æ—¶é—´æŸè€—æä½ï¼Œé€šå¸¸ä¸ºæ¯«ç§’çº§åˆ«ã€‚\\

For example, suppose two rules $R_1$ and $R_2$ are classified as a Trigger Conflict type of rule conflict during static analysis. The assertion verification process is as follows: (1) Step one: observe the occurrence of $T_1$, $C_1$, and $A_1$, indicating that rule $R_1$ has been triggered, passed the condition check, and successfully executed the expected action; (2) Step two: observe the occurrence of $T_2$ and $C_2$, indicating that rule $R_2$ has been triggered and passed the condition check, and the platform is about to execute the default action of $R_2$; (3) Step three: observe that the time interval between the occurrence of events $A_1$ and $T_2$ is very short, less than the threshold $\delta$. If all three steps are true, it can be concluded that the execution of rule $R_1$ led to the triggering and impending execution of rule $R_2$. To prevent coincidence in real-world scenarios (i.e., independent execution of $R_1$ and $R_2$ close in time), $\delta$ is set to a minimal threshold (e.g., 0.1s or 10ms). The system's low runtime overhead (millisecond level) ensures that valid conflicts are not missed due to processing delays. There is no need to worry that system processing time overhead will cause the threshold $\delta$ to be too small, leading to the failure to detect a rule conflict, as the time overhead in the system is extremely low, typically at the millisecond level.

\subsubsection{Runtime Controller and Strategy Execution}

% è¿è¡Œæ—¶æ§åˆ¶å™¨åœ¨æ—¥å¸¸çŠ¶æ€ä¸‹è´Ÿè´£è¾…åŠ©çŠ¶æ€è¯»å–ã€‚å®ƒç›‘å¬åœ¨è§„åˆ™è§¦å‘äº‹ä»¶ä¸è§„åˆ™æ¡ä»¶æ£€æµ‹äº‹ä»¶ï¼Œå¹¶å°†è¯¥äº‹ä»¶å‘é€ç»™è§„åˆ™äº‹ä»¶ç›‘å¬æ¨¡å—ä»è€Œå®ç°å¯¹èŠ‚ç‚¹çš„è¯†åˆ«ï¼Œä»–ç›‘å¬å·²è¯†åˆ«èŠ‚ç‚¹æ§åˆ¶çš„è®¾å¤‡çš„çŠ¶æ€ï¼Œå¹¶åœ¨è®¾å¤‡çŠ¶æ€æ”¹å˜æ—¶å°†äº‹ä»¶å‘é€ç»™äº‹ä»¶ç›‘å¬æ¨¡å—ï¼Œä»è€Œå®ç°å¯¹å·²è¯†åˆ«èŠ‚ç‚¹çš„é—å¿˜ã€‚å®ƒä¹Ÿè´Ÿè´£è·å–ç³»ç»ŸçŠ¶æ€ï¼ŒåŒ…æ‹¬ç³»ç»Ÿä¸­è®¾å¤‡å®ä½“çŠ¶æ€ã€ç³»ç»Ÿæ—¶é—´ã€äº‹ä»¶å‘ç”Ÿæ—¶é—´ï¼Œä»¥è¾…åŠ©æ–­è¨€éªŒè¯çš„å®Œæˆã€‚

% é™¤æ­¤ä¹‹å¤–ï¼Œè¿è¡Œæ—¶æ§åˆ¶å™¨æ›´æ ¸å¿ƒçš„åŠŸèƒ½æ˜¯æ‰§è¡Œå†²çªç¼“è§£ã€‚ä¸€æ—¦æ–­è¨€éªŒè¯ç¡®è®¤äº†å³å°†å‘ç”Ÿçš„å†²çªï¼Œè¿è¡Œæ—¶æ§åˆ¶å™¨å°†æ¥ç®¡è®¾å¤‡æ§åˆ¶æƒï¼Œè¿›è¡Œå†²çªç¼“è§£ã€‚æ ¹æ®é™æ€åˆ†æé˜¶æ®µç”Ÿæˆçš„å®šåˆ¶åŒ–å¤„ç†ç­–ç•¥ï¼Œæ§åˆ¶å™¨ä¼šæ‹¦æˆªé»˜è®¤çš„è§„åˆ™æ‰§è¡Œæµç¨‹å¹¶æ‰§è¡Œå®šåˆ¶åŒ–çš„å¤„ç†ç­–ç•¥ï¼ˆä¾‹å¦‚ï¼Œé˜»æ­¢ $R_j$ çš„æ‰§è¡Œæˆ–å¼ºåˆ¶ $R_i$ æ‰§è¡Œï¼‰ï¼Œä»è€Œåœ¨è§„åˆ™çœŸæ­£å‘æ‰§è¡Œä¹‹å‰æ¶ˆé™¤å®‰å…¨éšæ‚£ã€‚

The Runtime Controller is responsible for assisting state reading during normal operations. It monitors rule trigger events and rule condition check events, and sends these events to the Rule Event Listening module to achieve node identification. It monitors the status of devices controlled by the identified nodes and sends an event to the event listening module when the device status changes, thus enabling the forgetting of the identified nodes. It is also responsible for obtaining the system state, including device entity statuses, system time, and event occurrence times, to assist with assertion verification.

In addition, the core function of the Runtime Controller is to execute conflict mitigation. Once assertion verification confirms an Impending Rule Conflict, the Runtime Controller takes over device control and performs conflict mitigation. According to the customized handling strategy generated in the static analysis phase, the controller will intercept the default rule execution flow and execute the customized handling strategy (e.g., preventing the execution of $R_j$ or enforcing the execution of $R_i$), thereby eliminating security risks before the rule truly executes.