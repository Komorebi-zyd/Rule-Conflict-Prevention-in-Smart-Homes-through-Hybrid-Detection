\section{Design}

\subsection{Overview}
\begin{figure*}[htbp]
	\centering
	\includegraphics[width=\textwidth]{figure/overall_design.png}
	\caption{Overall Architecture of Our Approach}
	\label{overall_design}
\end{figure*}
% æˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ªå®Œæ•´çš„ç³»ç»Ÿï¼Œæ—¨åœ¨é€šè¿‡é™æ€ä¸ŽåŠ¨æ€åˆ†æžç›¸ç»“åˆçš„æ–¹å¼æ£€æµ‹è§„åˆ™äº¤äº’ä¸­å­˜åœ¨çš„æ½œåœ¨è§„åˆ™å†²çªï¼Œå¹¶åœ¨å†²çªå‘ç”Ÿå‰è‡ªåŠ¨æ‰§è¡Œå®šåˆ¶åŒ–çš„å†²çªå¤„ç†ç­–ç•¥ï¼Œé¿å…å®žé™…å†²çªçš„å‘ç”Ÿã€‚å¦‚å›¾ Fig.\ref{overall_design} æ‰€ç¤ºï¼Œæˆ‘ä»¬çš„æ–¹æ³•ä¸»è¦åŒ…æ‹¬ä¸¤ä¸ªé˜¶æ®µï¼š1) é™æ€åˆ†æžï¼›2) åŠ¨æ€æ£€æµ‹ä¸Žå†²çªå¤„ç†ã€‚
We presents a complete system designed to detect potential rule conflicts within rule interactions through a combination of static and dynamic analysis. The system automatically executes customized conflict resolution strategies before conflicts occur, preventing their actual manifestation. As illustrated in Fig.\ref{overall_design}, our approach primarily comprises two phases: 1) Static Analysis; 2) Dynamic Detection and Conflict Resolution.

% é™æ€åˆ†æžé˜¶æ®µåŒ…å«è§„åˆ™å»ºæ¨¡æ¨¡å—ã€å½¢å¼åŒ–åˆ†æžæ¨¡å—ã€é™æ€è§„åˆ™å†²çªæ£€æµ‹æ¨¡å—ä»¥åŠå†²çªå¤„ç†ç­–ç•¥ç”Ÿæˆæ¨¡å—ã€‚é¦–å…ˆï¼Œå¯¹æ™ºèƒ½å®¶å±…ç³»ç»Ÿä¸­çš„è§„åˆ™è¿›è¡Œé‡æ–°å»ºæ¨¡ï¼Œä»¥åŒºåˆ†å®¶åº­çŽ¯å¢ƒä¸­çš„ä¸åŒåŒºåŸŸã€‚ç„¶åŽï¼Œå½¢å¼åŒ–åˆ†æžæ¨¡å—åŸºäºŽæ–°çš„è§„åˆ™æ¨¡åž‹æå–æ‰€æœ‰ç±»åž‹çš„è§„åˆ™äº¤äº’ï¼Œå¹¶ç”Ÿæˆç›¸åº”çš„äº¤äº’åˆ†æžæ•°æ®ã€‚ç”¨æˆ·çš„å®žä½“å®‰å…¨é…ç½®å°†åº”ç”¨äºŽé™æ€è§„åˆ™å†²çªæ£€æµ‹æ¨¡å—ï¼Œç”¨äºŽä»Žè§„åˆ™äº¤äº’é›†åˆä¸­è¯†åˆ«å‡ºçœŸæ­£çš„è§„åˆ™å†²çªã€‚è€ƒè™‘åˆ°è§„åˆ™äº¤äº’æ˜¯å¦æž„æˆå†²çªå…·æœ‰ä¸»è§‚æ€§ï¼Œç³»ç»Ÿæä¾›ç”¨æˆ·é…ç½®ç•Œé¢ï¼Œä»¥è‡ªç„¶è¯­è¨€çš„å½¢å¼å±•ç¤ºå½¢å¼åŒ–åˆ†æžæ¨¡å—æå–çš„è§„åˆ™äº¤äº’åˆ†æžæ•°æ®ï¼Œè¾…åŠ©ç”¨æˆ·è¿›è¡Œå†²çªåˆ¤å®šã€‚æœ€åŽï¼Œå†²çªå¤„ç†ç­–ç•¥ç”Ÿæˆæ¨¡å—ä¸ºæ¯ä¸ªå·²è¯†åˆ«çš„è§„åˆ™å†²çªç”Ÿæˆå®šåˆ¶åŒ–çš„å¤„ç†ç­–ç•¥ã€‚
The static analysis phase includes a rule modeling module, a formal analysis module, a static rule conflict detection module, and a conflict resolution strategy generation module. Initially, the rules in the smart home system are remodeled to differentiate between zones within the environment. Subsequently, the formal analysis module extracts all types of rule interactions based on the new rule model and generates corresponding interaction analysis data. The user's entity safety configuration is then applied to the static rule conflict detection module, which identifies actual rule conflicts from the set of rule interactions. Recognizing the subjectivity inherent in defining a rule interaction as a conflict, the system presents the rule interaction data extracted by the formal analysis module to the user through a user configuration interface in natural language in order to facilitate the user determining rule conflicts. Finally, the conflict resolution strategy generation module generates customized resolution strategies for each identified rule conflict.

% åŠ¨æ€æ£€æµ‹ä¸Žå†²çªå¤„ç†é˜¶æ®µåŒ…å«è§„åˆ™äº‹ä»¶ç›‘å¬æ¨¡å—ã€æ–­è¨€éªŒè¯æ¨¡å—å’Œå‘½ä»¤ç”Ÿæˆæ¨¡å—ã€‚æ­¤å¤–ï¼Œæ™ºèƒ½å®¶å±…ç³»ç»Ÿï¼ˆä¾‹å¦‚ Home Assistantï¼‰ä¸­çš„è¿è¡ŒæŽ§åˆ¶å™¨æ¨¡å—å°†è¾…åŠ©å®ŒæˆåŠ¨æ€è§„åˆ™å†²çªæ£€æµ‹ä¸Žé¢„é˜²ã€‚è§„åˆ™äº‹ä»¶ç›‘å¬æ¨¡å—å®žæ—¶ç›‘å¬è§„åˆ™æ‰§è¡Œä¿¡æ¯ã€‚å½“ä¸€æ¡è§„åˆ™è¢«è§¦å‘ï¼Œå¹¶åœ¨æ¡ä»¶æ£€æŸ¥å‰åŽï¼Œè¯¥æ¨¡å—ä¼šå°†ç›¸å…³ä¿¡æ¯å‘é€ç»™æ–­è¨€éªŒè¯æ¨¡å—ã€‚æ–­è¨€éªŒè¯æ¨¡å—å°†åŸºäºŽåŽ†å²è§„åˆ™æ‰§è¡Œäº‹ä»¶ã€å½“å‰æ‰§è¡Œè§„åˆ™ä¿¡æ¯ä»¥åŠç›¸å…³è®¾å¤‡çŠ¶æ€ä¿¡æ¯è¿›è¡Œæ–­è¨€éªŒè¯ï¼Œåˆ¤æ–­è§„åˆ™å†²çªæ˜¯å¦å®žé™…å‘ç”Ÿã€‚è‹¥ç¡®è®¤å†²çªå³å°†å‘ç”Ÿï¼Œå‘½ä»¤ç”Ÿæˆæ¨¡å—å°†æ ¹æ®é™æ€åˆ†æžé˜¶æ®µç”Ÿæˆçš„å†²çªå¤„ç†ç­–ç•¥ï¼Œç”Ÿæˆç›¸åº”çš„æ‰§è¡Œå‘½ä»¤ï¼Œå¹¶ç”±è¿è¡ŒæŽ§åˆ¶å™¨æ¨¡å—å¼ºåˆ¶æ‰§è¡Œã€‚
The dynamic detection and conflict resolution phase includes a rule event listener module, an assertion verification module, and a command generation module. Additionally, the runtime controller module within the smart home system (e.g., Home Assistant) assists in dynamic rule conflict detection and prevention. The rule event listener module monitors the rule execution information in real time. When a rule is triggered, the listener module sends related information to the assertion verification module both before and after condition checking. Based on historical rule execution events, current rule information, and relevant device state information, the assertion verification module then performs assertion verification to determine whether a rule conflict has indeed occurred. If so, the command generation module will generate execution commands with the current rule conflict information about to occur and the rule conflict resolution strategy from static detection, which will be enforced by the runtime controller module.

\subsection{Static Analysis}

\subsubsection{Rule Modeling}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.4\textwidth]{figure/classification_observation.png}
	\caption{Rule Interaction Pattern}
	\label{classification_observation}
\end{figure}

% åœ¨ä»‹ç»é™æ€é˜¶æ®µä¹‹å‰ï¼Œé¦–å…ˆé˜è¿°æœ¬æ–¹æ¡ˆå¯¹è§„åˆ™äº¤äº’ä¸Žè§„åˆ™å†²çªçš„åˆ†ç±»æ–¹æ³•ã€‚åŸºäºŽä¹‹å‰çš„è§‚å¯Ÿï¼Œæˆ‘ä»¬é‡‡ç”¨Fig.\ref{classification_observation}çš„æ–¹å¼å°†è§„åˆ™ä¹‹é—´çš„äº¤äº’ç±»åž‹å½’çº³ä¸ºä»¥ä¸‹ï¼šä¸€æ¡è§„åˆ™çš„æ‰§è¡Œç»“æžœå¯¹å¦ä¸€æ¡è§„åˆ™çš„è§¦å‘å™¨ã€æ¡ä»¶æˆ–åŠ¨ä½œäº§ç”Ÿç›´æŽ¥æˆ–é—´æŽ¥çš„å½±å“ã€‚ç”±æ­¤ï¼Œæˆ‘ä»¬å°†è§„åˆ™äº¤äº’åˆ†ä¸ºä»¥ä¸‹å‡ ç±»ï¼šè§¦å‘å™¨äº¤äº’ (Trigger Interaction)ã€æ¡ä»¶äº¤äº’ (Condition Interaction)ã€åŠ¨ä½œäº¤äº’ (Action Interaction)ã€é—´æŽ¥è§¦å‘å™¨äº¤äº’ (Indirect Trigger Interaction)ã€é—´æŽ¥æ¡ä»¶äº¤äº’ (Indirect Condition Interaction) å’Œé—´æŽ¥åŠ¨ä½œäº¤äº’ (Indirect Action Interaction)ã€‚ç›¸åº”åœ°ï¼Œæˆ‘ä»¬å®šä¹‰äº†å…­ç§è§„åˆ™å†²çªç±»åž‹ï¼šè§¦å‘å™¨å†²çª (Trigger Conflict)ã€æ¡ä»¶å†²çª (Condition Conflict)ã€åŠ¨ä½œå†²çª (Action Conflict)ã€é—´æŽ¥è§¦å‘å™¨å†²çª (Indirect Trigger Conflict)ã€é—´æŽ¥æ¡ä»¶å†²çª (Indirect Condition Conflict) å’Œé—´æŽ¥åŠ¨ä½œå†²çª (Indirect Action Conflict)ã€‚
Before formally introducing the static phase, it is first necessary to clarify our approach to classifying rule interactions and rule conflicts. Based on previous observations, we summarize the types of interactions between rules as shown in Fig.\ref{classification_observation}: the execution result of one rule can have direct or indirect impacts on the triggers, conditions, or actions of another rule. Accordingly, we classify rule interactions into the following categories: Trigger Interaction, Condition Interaction, Action Interaction, Indirect Trigger Interaction, Indirect Condition Interaction, and Indirect Action Interaction. Correspondingly, we define six types of rule conflicts: Trigger Conflict, Condition Conflict, Action Conflict, Indirect Trigger Conflict, Indirect Condition Conflict, and Indirect Action Conflict.

% æ™ºèƒ½å®¶å±…ç³»ç»Ÿä¸­çš„è§„åˆ™é€šå¸¸ä»¥é™æ€æ–‡ä»¶å½¢å¼å­˜å‚¨ï¼Œä»Žä¸­å¯ä»¥æå–è§„åˆ™çš„è§¦å‘å™¨ (T)ã€æ¡ä»¶ (C) å’ŒåŠ¨ä½œ (A) å±žæ€§ï¼Œå¹¶å¿«é€Ÿå»ºæ¨¡ä¸º $\langle T,C,A \rangle$ æ¨¡åž‹ã€‚ç„¶è€Œï¼Œä»…å‡­è¿™äº›æ•°æ®ä¸è¶³ä»¥æ£€æµ‹ä¸åŒå®¶åº­åŒºåŸŸä¸­ä¾§é¢é€šé“çš„å½±å“ï¼Œä¾‹å¦‚ä¸åŒè§„åˆ™å¯¹å§å®¤æ¸©åº¦çš„å½±å“æ‰€å¼•å‘çš„äº¤äº’ï¼Œæˆ–è€…ä¸åŒè§„åˆ™å¼€å¯é«˜åŠŸè€—è®¾å¤‡å¯¼è‡´å®¶åº­ç”¨ç”µåŠŸçŽ‡å‡é«˜ï¼Œä»Žè€Œè§¦å‘èŠ‚ç”µè§„åˆ™ç­‰ã€‚å› æ­¤ï¼Œéœ€è¦å¼•å…¥æ–°çš„å±žæ€§ $E$ã€‚å®šä¹‰ $E=[e^1, e^2,\dots]$ï¼Œ$e^i=(area, channel, trend)$ã€‚å…¶ä¸­ï¼Œ$area$ è¡¨ç¤ºé—´æŽ¥é€šé“çš„åŒºåŸŸç‰¹å¾ï¼Œå¦‚åŽ¨æˆ¿ã€å®¢åŽ…æˆ–æ•´ä¸ªå®¶åº­ç­‰ï¼›$channel$ è¡¨ç¤ºä¾§é¢é€šé“åç§°ï¼Œå¦‚æ¸©åº¦ã€æ¹¿åº¦ã€å…‰ç…§å¼ºåº¦ç­‰ï¼›$trend$ è¡¨ç¤ºè¯¥ä¾§é¢å½±å“çš„å½±å“è¶‹åŠ¿ï¼Œå¦‚å‡é«˜ã€é™ä½Žç­‰ã€‚å¯¹äºŽè§„åˆ™çš„è§¦å‘å™¨æˆ–æ¡ä»¶ï¼Œå¦‚æžœ $e$ ä¸º $\langle kitchen, temperature, increases\rangle$ï¼Œåˆ™è¡¨ç¤ºå…¶ä»–è§„åˆ™çš„æ‰§è¡Œç»“æžœå¯èƒ½å¯¼è‡´åŽ¨æˆ¿æ¸©åº¦å‡é«˜ï¼Œä»Žè€Œä½¿å½“å‰è§„åˆ™çš„è§¦å‘å™¨æ›´æ˜“è§¦å‘æˆ–æ¡ä»¶æ›´æ˜“æ»¡è¶³ã€‚å¯¹äºŽè§„åˆ™çš„åŠ¨ä½œï¼Œå¦‚æžœ $e$ ä¸º $\langle kitchen, temperature, increases\rangle$ï¼Œåˆ™è¡¨ç¤ºå½“å‰è§„åˆ™çš„æ‰§è¡Œå¯èƒ½å¯¼è‡´åŽ¨æˆ¿æ¸©åº¦å‡é«˜ã€‚å±žæ€§ $E$ åŸºäºŽç”¨æˆ·çœŸå®žçš„å®¶åº­æƒ…å†µå’Œç›¸å…³è§„åˆ™ç¡®å®šã€‚ä¾‹å¦‚ï¼Œå¦‚æžœä¸€ä¸ªå®¶åº­ä¸­æ²¡æœ‰ä»»ä½•ä¸Ž "æ¹¿åº¦" ç›¸å…³çš„è§„åˆ™ï¼Œåˆ™æ— éœ€å°† $channel$ è®¾ç½®ä¸º "æ¹¿åº¦"ã€‚ç”±æ­¤ï¼Œè§„åˆ™å¯ä»¥è¢«é‡æ–°å»ºæ¨¡ä¸º $R=\langle T,C,A,E\rangle $ æˆ– $R=\langle T,C,A,E_T,E_C,E_A \rangle$ å½¢å¼ï¼Œç§°ä¸º TCAE æ¨¡åž‹ã€‚
In smart home systems, rule configuration is usually stored as static files, from which the triggers, conditions, and action attributes of a rule can be extracted, and quickly modeled as a $\langle T,C,A \rangle$ model. However, the above data is insufficient to support the detection of the effects of side channels in different home areas within smart home systems. For example, rule interactions may be caused by different rules affecting the bedroom temperature, or by different rules turning on high-power devices, leading to an increase in the household's power consumption and subsequently triggering related rules to conserve electricity. Therefore, a new attribute $E$ needs to be introduced. $E$ is defined as$E=[e^1, e^2,\dots]$ and $e^i=(area, channel, trend)$, where $area$ indicates the spatial characteristics of the channel, such as the kitchen, living room, or the whole home; $channel$ indicates the name of the other channel which rules may impact each other, such as temperature, humidity, illuminance and so on; and $trend$ indicates the direction of the influence of the other channel, such as an increase and decrease. For the trigger/condition of a rule, if $e$ is $\langle kitchen, temperature, increases\rangle$, it means that if the execution results of other rules may lead to an increase in kitchen temperature, then the trigger/condition of the current rule is more likely to be met. For the action execution of a rule, if $e$ is $\langle kitchen, temperature, increases\rangle$, it means that the execution of the current rule may promote an increase in kitchen temperature. The attribute $E$ will be determined based on the user's actual home situation and the related rules. For example, if there are no rules concerning "humidity" in a home, then there is no need to set the $channel$ attribute of $e$ as "humidity". Thus, a rule can be re-modeled in the following form: $R=\langle T,C,A,E\rangle $ or $R=\langle T,C,A,E_T,E_C,E_A \rangle$ which called TCAE model.

\subsubsection{Formal Analysis}

\begin{table*}[htbp]
	\begin{center}
		\caption{Formal Analysis Expression}
		\label{Formal_Analysis_Expression}
		\begin{adjustbox}{width=0.95\textwidth}
			\begin{tabular}[width=0.95\textwidth]{c|c} 
				\hline
				\textbf{Classification} & \textbf{Expression}\\
				\hline
				\text{Trigger Interaction} & $(\exists a_{1}\in A_{1})\wedge(a_{1}\rightarrow T_{2})$ \\
				\hline
				\text{Condition Interaction} & $\left((A_{1}\nrightarrow C_{2})\wedge\left((T_{1}\neq T_{2})\wedge(R_{1}\neq R_{2})\right)\right)\vee\left((A_{1}\to\mathcal{C}_{2})\wedge\left((T_{1}\neq T_{2})\wedge(R_{1}\neq R_{2})\right)\right)$ \\
				\hline
				\text{Action Interaction} & $(\exists a_{1}\in A_{1})\wedge(\exists a_{2}\in A_{2})\wedge(a_{1}\perp a_{2})$ \\
				\hline
				\text{Indirect Trigger Interaction} & $(\exists a_{1}\in A_{1})\wedge\left(E_{a_{1}}=E_{T_{1}}\right)$ \\
				\hline
				\text{Indirect Condition Interaction} & $\left(\left(E_{A_{1}}\perp E_{C_{2}}\right)\vee\left(E_{A_{1}}=E_{C_{2}}\right)\right)\wedge\left(R_{1}\neq R_{2}\right)$ \\
				\hline
				\text{Indirect Action Interaction} & $(\exists a_{1}\in A_{1})\wedge(\exists a_{2}\in A_{2})\wedge\left(D_{a_{1}}\neq D_{a_{2}}\right)\wedge\left(E_{a_{1}}\perp E_{a_{2}}\right)$ \\
				\hline
			\end{tabular}
		\end{adjustbox}
	\end{center}
\end{table*}

% åŸºäºŽ TCA æ¨¡åž‹è¿›è¡Œè§„åˆ™å†²çªåˆ†ç±»ï¼Œå‡è®¾è§„åˆ™ $R_1=\langle T_1,C_1,A_1,E_{T_1},E_{C_1},E_{A_1} \rangle$ å’Œ ð‘…â‚‚=(ð‘‡â‚‚, ð¶â‚‚, ð´â‚‚, ð¸(ð‘‡â‚‚), ð¸(ð¶â‚‚), ð¸(ð´â‚‚)) è¡¨ç¤ºåœ¨åŒä¸€ç³»ç»Ÿä¸­è®¾ç½®çš„ä¸¤æ¡è§„åˆ™ã€‚å…¶ä¸­ï¼ŒTã€Cã€A å’Œ E åˆ†åˆ«è¡¨ç¤ºå¯¹åº”çš„å±žæ€§ã€‚ä½¿ç”¨ $\rightarrow$ è¡¨ç¤ºä¿ƒä½¿è§¦å‘å™¨è§¦å‘æˆ–æ¡ä»¶æ»¡è¶³ï¼Œ$\nrightarrow$ è¡¨ç¤ºç¦æ­¢æ¡ä»¶æ»¡è¶³ã€‚å¯¹äºŽ channel å±žæ€§ï¼Œ$\bot$ è¡¨ç¤ºä¸¤ä¸ª channel å±žæ€§å…·æœ‰ç›¸åŒçš„ $area$ å’Œ $channel$ï¼Œä½† $trend$ ç›¸åï¼ˆä¾‹å¦‚ï¼ŒåŽ¨æˆ¿æ¸©åº¦å‡é«˜ä¸ŽåŽ¨æˆ¿æ¸©åº¦é™ä½Žï¼‰ã€‚æ­¤å¤–ï¼Œ$\bot$ ä¹Ÿè¡¨ç¤ºä¸¤ä¸ªåŠ¨ä½œç›¸äº’å†²çªï¼ˆä¾‹å¦‚ï¼Œå¼€å¯ç©ºè°ƒä¸Žå…³é—­ç©ºè°ƒï¼‰ã€‚"=" è¡¨ç¤ºä¸¤ä¸ª channel å±žæ€§å…·æœ‰ç›¸åŒçš„ $area$ã€$channel$ å’Œ $trend$ï¼Œæˆ–è€…ä¸¤ä¸ªè§¦å‘å™¨æˆ–æ¡ä»¶ç›¸åŒã€‚
According to the TCA model for rule conflict classification, let rule $R_1=\langle T_1,C_1,A_1,E_{T_1},E_{C_1},E_{A_1} \rangle$ and rule  $R_2=\langle T_2,C_2,A_2,E_{T_2},E_{C_2},E_{A_2} \rangle$ be to represent two rules set in the same system, where T, C, A, and E respectively represent the corresponding attribute. Using $\rightarrow$ to indicate that a trigger is activated or a condition is met, and $\nrightarrow$ to indicate that a condition is prohibited.$\bot$ denotes that the two channel attributes have the same area and channel but opposite trends (for example, rising kitchen temperature versus falling kitchen temperature), or it indicates that two actions are in conflict (such as turning on the air conditioner versus turning it off), while "=" indicates that the two channel attributes have the same area, channel, and trend, or that there are two identical triggers or conditions.

% å½¢å¼åŒ–åˆ†æžæ¨¡å—éåŽ†æ¯ä¸ªè§„åˆ™æ¨¡åž‹ï¼Œå¹¶è¿›è¡Œè¡¨è¾¾å¼éªŒè¯ã€‚è‹¥è¡¨è¾¾å¼æˆç«‹ï¼Œåˆ™è¡¨ç¤ºä¸¤æ¡è§„åˆ™æ»¡è¶³å¯¹åº”çš„è§„åˆ™äº¤äº’ç±»åž‹ã€‚è§„åˆ™å†²çªæ˜¯è§„åˆ™äº¤äº’çš„ç‰¹ä¾‹ï¼Œå› æ­¤ï¼Œè¯¥è¡¨è¾¾å¼ä»…ç”¨äºŽç­›é€‰å­˜åœ¨äº¤äº’çš„è§„åˆ™ï¼Œè€Œè¦åˆ¤æ–­è§„åˆ™äº¤äº’æ˜¯å¦æž„æˆå®žé™…çš„è§„åˆ™å†²çªï¼Œè¿˜éœ€è¦è¿›ä¸€æ­¥çš„æ£€æµ‹ã€‚å…·ä½“çš„è¡¨è¾¾å¼å¦‚ Table.\ref{Formal_Analysis_Expression} æ‰€ç¤ºã€‚ç”±æ­¤ï¼Œå½¢å¼åŒ–åˆ†æžæ¨¡å—èƒ½å¤Ÿåˆ†æžå¾—åˆ°å…·ä½“çš„è§„åˆ™äº¤äº’åˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å«äº†æ‰€æœ‰è§„åˆ™äº¤äº’åŠå…¶äº¤äº’æ¨¡å¼ä¿¡æ¯ã€‚
The formal analysis module will traverse each rule model and then expression validation. If an expression is satisfied, it indicates that the two rules meet the corresponding rule interaction classification. Rule conflict is a special case of rule interaction, and that expression can only filter out interacting rules. further detection is required to determine whether a rule interaction constitutes a rule conflict.The formal analysis module can analyze and obtain a specific list of rule interactions, which includes all rule interactions and interaction pattern information.

\subsubsection{Rule Conflict Detection and Resolution Strategy Generation}
% å®žä½“å®‰å…¨é…ç½®æ˜¯å®‰å…¨æ•æ„Ÿè®¾å¤‡å®žä½“çš„å®‰å…¨çŠ¶æ€é›†åˆï¼Œç”¨äºŽè¡¨ç¤ºæ™ºèƒ½å®¶å±…ç³»ç»Ÿä¸­å‘ç”Ÿå†²çªæ—¶åº”ä¼˜å…ˆä¿æŒçš„çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œé—¨åº”ä¿æŒ "å…³é—­" çŠ¶æ€ï¼Œæ¶ˆé˜²å–·æ·‹å¤´åº”ä¿æŒ "å¼€å¯" çŠ¶æ€ã€‚è§„åˆ™å†²çªæ£€æµ‹æ¨¡å—å¯¹è§„åˆ™äº¤äº’åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è¿›è¡Œå®žä½“å®‰å…¨æ£€æŸ¥ï¼Œä»¥ç¡®å®šè§„åˆ™äº¤äº’æ˜¯å¦è¿åå®žä½“å®‰å…¨çŠ¶æ€ï¼Œä»Žè€Œå¼•å‘æ½œåœ¨çš„è§„åˆ™å†²çªã€‚
Entity safety configuration is a set of safety states for a security-sensitive device entity, used to indicate the preferred state to maintain when a conflict occurs in a smart home systemâ€”for example, a door should be "closed" and a fire sprinkler should be "on." The rule conflict detection module performs an entity safety on all elements in the rule interaction list to determine whether a rule interaction violates the entity safety state, potentially causing a rule conflict.

% å…·ä½“çš„æ£€æŸ¥æ–¹æ³•å¦‚ä¸‹ï¼šå¯¹äºŽåŒ…å«ä¸¤æ¡è§„åˆ™çš„è§„åˆ™äº¤äº’ï¼Œéœ€è¦å…³æ³¨äº¤äº’å®ŒæˆåŽæ˜¯å¦è¿åå®žä½“å®‰å…¨é…ç½®çš„è¦æ±‚ã€‚ä¸ºæ­¤ï¼Œä¸ºæ¯æ¡è§„åˆ™è®¾å®šä¸€ä¸ªå®‰å…¨å€¼å‚æ•° $sf$ã€‚è‹¥è§„åˆ™çš„æ‰§è¡Œç»“æžœæ›´ç¬¦åˆå®žä½“å®‰å…¨çŠ¶æ€é…ç½®ï¼Œåˆ™ $sf$ å€¼è¶Šé«˜ï¼Œåä¹‹è¶Šä½Žã€‚$sf$ å€¼é€šè¿‡éåŽ†æ‰€æœ‰å®žä½“å®‰å…¨é…ç½®ï¼Œé‡‡ç”¨çº¿æ€§å‡½æ•°è®¡ç®—ã€‚ä¾‹å¦‚ï¼Œè‹¥è§„åˆ™çš„æ‰§è¡Œç»“æžœæ˜¯å…³é—­é—¨ï¼Œè¿™ç¬¦åˆå®žä½“ "é—¨" çš„å®‰å…¨çŠ¶æ€ "å…³é—­"ï¼Œåˆ™è¯¥è§„åˆ™çš„ $sf$ å€¼åœ¨åŽŸæœ‰åŸºç¡€ä¸ŠåŠ ä¸€ï¼Œåä¹‹åˆ™å‡ä¸€ã€‚é»˜è®¤å€¼ä¸ºé›¶ã€‚
The specific inspection method is as follows: a rule interaction includes two rules, and attention should be paid to whether the entity safety configuration requirements are violated after this rule interaction is completed. Therefore, each rule sets a safety value parameter, $sf$. If the execution result of a rule is more inclined to meet the entity safety configuration, the $sf$ value is higher; otherwise, it is lower. The specific $sf$ value can be calculated using a linear function by traversing all the entity safety configurations. For example, if the execution result of a rule is closing a door, which is more in line with the entity safety state "closed" for the entity "door", then the rule's $sf$ is increased by one from the original value, Otherwise, it is decreased by one, with the default value being zero.

% é’ˆå¯¹ä¸åŒç±»åž‹çš„è§„åˆ™äº¤äº’ï¼Œè§„åˆ™å†²çªçš„åˆ¤å®šæ–¹æ³•æœ‰æ‰€ä¸åŒï¼š
% \begin{itemize}
	% 	\item å¯¹äºŽè§¦å‘å™¨äº¤äº’å’Œé—´æŽ¥è§¦å‘å™¨äº¤äº’ï¼Œå…³æ³¨ç¬¬äºŒæ¡è§„åˆ™çš„å®‰å…¨å€¼ $sf$ æ˜¯å¦å¤§äºŽé›¶ã€‚è‹¥å°äºŽé›¶ï¼Œåˆ™åˆ¤å®šä¸ºè§„åˆ™å†²çªã€‚
	% 	\item å¯¹äºŽæ¡ä»¶äº¤äº’å’Œé—´æŽ¥æ¡ä»¶äº¤äº’ï¼Œè‹¥ç¬¬ä¸€ä¸ªè§„åˆ™ç¦æ­¢äº†ç¬¬äºŒä¸ªè§„åˆ™çš„æ¡ä»¶ï¼Œä¸”ç¬¬äºŒä¸ªè§„åˆ™çš„ $sf$ å¤§äºŽé›¶ï¼Œåˆ™åˆ¤å®šä¸ºè§„åˆ™å†²çªï¼›åä¹‹ï¼Œè‹¥ç¬¬ä¸€ä¸ªè§„åˆ™ä½¿å¾—ç¬¬äºŒä¸ªè§„åˆ™çš„æ¡ä»¶å¾—ä»¥æ»¡è¶³ï¼Œä¸”ç¬¬äºŒä¸ªè§„åˆ™çš„ $sf$ å°äºŽé›¶ï¼Œä¹Ÿåˆ¤å®šä¸ºè§„åˆ™å†²çªã€‚è¿™è¡¨æ˜Žå‰ä¸€æ¡è§„åˆ™çš„å½±å“å¯¼è‡´åŽä¸€æ¡æ›´ç¬¦åˆå®žä½“å®‰å…¨çŠ¶æ€çš„è§„åˆ™æœªè¢«æ‰§è¡Œï¼Œæˆ–å¯¼è‡´åŽä¸€æ¡ä¸Žå®žä½“å®‰å…¨çŠ¶æ€ç›¸è¿èƒŒçš„è§„åˆ™è¢«æ‰§è¡Œã€‚
	% 	\item å¯¹äºŽåŠ¨ä½œäº¤äº’å’Œé—´æŽ¥åŠ¨ä½œäº¤äº’ï¼Œè‹¥å…¶ä¸­åŒ…å«çš„ä¸¤æ¡è§„åˆ™çš„å®‰å…¨å€¼ä¹‹ä¸€ä¸ä¸ºé›¶ï¼Œåˆ™åˆ¤å®šä¸ºè§„åˆ™å†²çªã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå³ä½¿ä¸¤æ¡è§„åˆ™çš„å®‰å…¨å€¼éƒ½å¤§äºŽé›¶ï¼Œä»å¯èƒ½åˆ¤å®šä¸ºè§„åˆ™å†²çªï¼Œå› ä¸ºæ­¤ç±»äº¤äº’ä¸­çš„ä¸¤æ¡è§„åˆ™çš„æ‰§è¡Œç»“æžœæ˜¯ç›¸äº’çŸ›ç›¾çš„ï¼Œé€šå¸¸åªéœ€æ‰§è¡Œå…¶ä¸­ä¸€æ¡è§„åˆ™ã€‚
	% \end{itemize}
For different rule interactions, the method for determining rule conflicts varies. 
\begin{itemize}
	\item For Trigger Interaction and Indirect Trigger Interaction, the focus is on whether the safety value $sf$ of the second rule is greater than zero; if it is less than zero, then it is determined to be a rule conflict.
	\item For Condition Interaction and Indirect Condition Interaction, if the first rule in a rule interaction prohibits the condition of the second rule while the second ruleâ€™s $sf$ is greater than zero, it is determined to be a rule conflict; or if the first rule satisfies the condition of the second rule while the second ruleâ€™s $sf$ is less than zero, it is determined to be a rule conflict. This indicates that due to the influence of the preceding rule, either the rule that is more inclined to the entity safety state was not executed for the latter rule, or the rule that contradicts the entity safety state was executed.
	\item For Action Interaction and Indirect Action Interaction, if either of the two rules has a non-zero safety value, it is determined to be a rule conflict. In this case, it should be noted that if both rules have safety values greater than zero, it will also be deemed a rule conflict, because in the determination of this type of rule interaction, the execution results of the two rules are contradictory, and typically only one rule needs to be executed.
\end{itemize}

% ç”±æ­¤ï¼Œå¯ä»¥ä¸ºæ¯ç§è§„åˆ™å†²çªè®¾å®šå¤šç§å¤„ç†ç­–ç•¥ã€‚å…·ä½“çš„å†²çªå¤„ç†ç­–ç•¥å¯æ ¹æ® Table.\ref{Resolution_Policy_Decision} è¿›è¡Œé€‰æ‹©ã€‚
Based on this, multiple resolution strategies can be set for each rule. The specific conflict resolution strategy can be selected according to Table.\ref{Resolution_Policy_Decision}.

\begin{table*}[htbp]
	\begin{center}
		\caption{Resolution Policy Decision (Need modification)}
		\label{Resolution_Policy_Decision}
		\begin{adjustbox}{width=0.95\textwidth}
		\begin{tabular}{c|c|c}
			\hline
			\textbf{Classification} & \textbf{Decision} & \textbf{Options} \\
			\hline
			\multirow{3}{*}{\makecell{\textbf{Trigger Conflict} \\ \textbf{Indirect Trigger Conflict}}} 
			& $(sf_2 = 0)\vee(sf_2>0 \wedge sf_1\geq 0)$ & Not rule conflict \\
			\cline{2-3}
			& $sf_1 < 0 \land sf_2 \geq 0$ & Only execute $R_2$ \\
			\cline{2-3}
			& $sf_2 < 0$ & Cancel execution of $R_2$ \\
			\hline
			\multirow{3}{*}{\makecell{\textbf{Condition Conflict} \\ \textbf{Indirect Condition Conflict}}} 
			& $(A_{1}\rightarrow C_{2}\wedge sf_{2}>0)\vee(A_{1}\nrightarrow C_{2}\wedge sf_{2}<0)$ & Not rule conflict \\
			\cline{2-3}
			& $A_{1}\rightarrow C_{2}\wedge sf_{2}>0$ & Do not execute $R_2$\\
			\cline{2-3}
			& $A_{1}\nrightarrow C_{2}\wedge sf_{2}<0$ & Execute $R_2$ \\
			\hline
			\multirow{6}{*}{\makecell{\textbf{Action Conflict} \\ \textbf{Indirect Action Conflict}}} 
			& $sf_1 = 0 \land sf_2 = 0$ & Not rule conflict \\
			\cline{2-3}
			& $sf_1 > 0 \land sf_2 < 0$ & Only execute $R_1$ \\
			\cline{2-3}
			& $sf_1 < 0 \land sf_2 > 0$ & Only execute $R_2$ \\
			\cline{2-3}
			& $sf_1 > 0 \land sf_2 > 0 \land sf_1 > sf_2$ & Both rules are executed, but ended with $R_1$ \\
			\cline{2-3}
			& $sf_1 > 0 \land sf_2 > 0 \land sf_1 < sf_2$ & Both rules are executed, but ended with $R_2$ \\
			\cline{2-3}
			& $sf_1 < 0 \land sf_2 < 0$ & Neither rule will be executed \\
			\hline
		\end{tabular}
		\end{adjustbox}
	\end{center}
\end{table*}

\subsection{Dynamic Detection and Conflict Resolution}
\subsubsection{Assertion Verification}
%é™æ€æ£€æµ‹éƒ¨åˆ†å…¨éƒ¨ç¦»çº¿è¿è¡Œï¼ŒDynamic detection and Conflict resolutionéƒ¨åˆ†å°†ä¼šä»¥é™æ€æ£€æµ‹çš„è¾“å‡ºç»“æžœä½œä¸ºåŸºç¡€ï¼Œä¾‹å¦‚Rule Conflict Listå’ŒRule Conflict Resolution Strategyï¼Œå¯¹è§„åˆ™å†²çªè¿›è¡Œå®žæ—¶ç›‘æµ‹ä¸Žé¢„é˜²ã€‚Dynamic detection and Conflict resolutionçš„Rule Event Listener moduleå’ŒCommand Generation moduleä¸»è¦ä¾èµ–è¿è¡ŒæŽ§åˆ¶å™¨ï¼Œå®žçŽ°å¯¹è§„åˆ™äº‹ä»¶çš„ç›‘å¬ä¸Žå®žçŽ°åœ¨å†²çªäº‹ä»¶å‘ç”Ÿå‰å¯¹è®¾å¤‡çš„é»˜è®¤æ“ä½œæ‹¦æˆªä¸Žå†²çªå¤„ç†ç­–ç•¥æ‰§è¡Œï¼Œå› æ­¤ä»¥ä¸‹éƒ¨åˆ†é‡ç‚¹ä»‹ç»Assertion Verification module
The static detection part runs entirely offline, while the dynamic detection and conflict resolution part will be based on the output of the static detection, such as the rule conflict list and rule conflict resolution strategy, to monitor and prevent rule conflicts in real-time. The rule event listener module and command generation module of dynamic detection and conflict resolution mainly rely on Runtime Controller to listen to rule events and implement the interception of the device's default operations and the execution of conflict resolution strategies before conflict events occur. Therefore, the following part focuses on the assertion verification module.

%ï¼Œåœ¨æ™ºèƒ½å®¶å±…ç³»ç»Ÿè¿è¡Œæ—¶ï¼Œæ‰€æœ‰è§„åˆ™äº‹ä»¶å°†è¢«å®žæ—¶ç›‘å¬ã€‚å½“ä¸€æ¡è§„åˆ™è¢«è§¦å‘åŽï¼Œåœ¨å…¶æ¡ä»¶æ£€æŸ¥é˜¶æ®µå‰åŽéƒ½ä¼šè¿›è¡Œæ–­è¨€æ£€æµ‹ï¼Œä»¥åˆ¤æ–­å½“å‰ç³»ç»Ÿæ˜¯å¦å³å°†å‘ç”Ÿè§„åˆ™å†²çªã€‚æ–­è¨€æ£€æµ‹è¿‡ç¨‹ä¸­çš„æ‰€æœ‰ä¿¡æ¯éƒ½å°†é€šè¿‡è¿è¡ŒæŽ§åˆ¶å™¨æ¨¡å—èŽ·å–ï¼ŒåŒ…æ‹¬å½“å‰æ‰§è¡Œè§„åˆ™çš„ä¿¡æ¯ã€è¿‡åŽ»æ‰§è¡Œè§„åˆ™çš„ä¿¡æ¯ï¼Œä»¥åŠç›¸å…³å®žä½“è®¾å¤‡çš„å®žæ—¶çŠ¶æ€ä¸ŽåŽ†å²çŠ¶æ€å˜åŒ–ä¿¡æ¯ç­‰ã€‚
When the smart home system is running, rule events will be monitored in real-time. When a rule is triggered, assertion verification will be performed before and after the condition checking phase to determine whether a rule conflict is imminent. All information during the assertion verification process will be collected through the runtime controller module, including the information of the currently executing rule, the information of the previously executed rule, the real-time status of related entities, and past state change information.

% æ–­è¨€æ£€æµ‹ä¸»è¦åŒ…å«ä»¥ä¸‹å‡½æ•°ï¼š
Assertion detection mainly includes the following functions:

\begin{itemize}
	\item $obs()$: Observing the occurrence of an event (including the triggering of the trigger $obs(T)$,the passing of a condition check $obs(C)$, the failing of a condition check $obs(\neg C)$ and the execution of an action $obs(A)$
	\item $intime(X,Y,\delta)$: the time interval between events $X$ and $Y$ is less than $\delta$, with $\delta$ defaulting to 0.1 seconds
\end{itemize}

% ç”±æ­¤ï¼Œé’ˆå¯¹ä¸åŒç±»åž‹çš„è§„åˆ™å†²çªï¼Œå­˜åœ¨å¯¹åº”çš„æ–­è¨€æ£€æµ‹æ–¹æ³•ï¼Œå¦‚ Table.\ref{Assertion_Verification} æ‰€ç¤ºã€‚
Accordingly, for different types of rule conflicts, there are corresponding assertion verification methods, as shown in Table.\ref{Assertion_Verification}.

% ä¾‹å¦‚å­˜åœ¨ä¸¤æ¡è§„åˆ™$R_1$å’Œ$R_2$åœ¨é™æ€æ£€æµ‹ä¸­å±žäºŽTrigger Conoflictç±»åž‹çš„è§„åˆ™å†²çªï¼Œæ–­è¨€æ£€æµ‹è¿‡ç¨‹å¦‚ä¸‹ï¼š(1)ç¬¬ä¸€æ­¥ï¼Œåˆ†åˆ«è§‚å¯Ÿåˆ°$T_1$ï¼Œ$C_1$å’Œ$A_1$çš„å‘ç”Ÿï¼Œè¡¨æ˜Žè¡¨æ˜Žè§„åˆ™$R_1$è§¦å‘å¹¶é€šè¿‡æ¡ä»¶æ£€æµ‹åŽæˆåŠŸæ‰§è¡Œé¢„æœŸåŠ¨ä½œï¼›(2)ç¬¬äºŒæ­¥ï¼Œåˆ†åˆ«è§‚å¯Ÿåˆ°$T_2$å’Œ$C_2$çš„å‘ç”Ÿï¼Œè¡¨æ˜Žè§„åˆ™$R_2$è§¦å‘å¹¶é€šè¿‡äº†æ¡ä»¶æ£€æµ‹ï¼Œå¹³å°åŠå°†æ‰§è¡Œ$R_2$çš„é»˜è®¤åŠ¨ä½œï¼›(3)è§‚å¯Ÿåˆ°$A_1$å’Œ$T_2$ä¸¤ä¸ªäº‹ä»¶çš„å‘ç”Ÿçš„æ—¶é—´é—´éš”å¾ˆçŸ­ï¼Œæ—¶é—´é—´éš”å°äºŽé˜ˆå€¼$delta$ã€‚ä¸‰ä¸ªæ­¥éª¤å…¨éƒ¨ä¸ºçœŸåˆ™å¯ä»¥è®¤ä¸ºæ˜¯è§„åˆ™$R_1$çš„æ‰§è¡Œå¯¼è‡´äº†è§„åˆ™$R_2$è¢«è§¦å‘å¹¶å³å°†æ‰§è¡Œï¼Œä¸ºäº†é˜²æ­¢çœŸå®žä¸–ç•Œä¸­çš„å·§åˆå‘ç”Ÿï¼Œå³é¿å…æ˜¯å› ä¸ºå…¶ä»–çŽ°å®žåŽŸå› è§„åˆ™$R_1$ä¸Žè§„åˆ™$R_2$åœ¨ç¬¦åˆç”¨æˆ·é¢„æœŸæ¡ä»¶ä¸‹åˆ†åˆ«çŸ­æ—¶é—´å†…å‡ºå‘å¹¶æ‰§è¡Œè€Œå¯¼è‡´è¯¯åˆ¤ï¼Œè¿™é‡Œçš„$delta$é€šå¸¸è®¾ç½®å¾ˆå°çš„å€¼ï¼Œå¦‚0.1ç§’ç”šè‡³0.01ç§’ã€‚ä¸å¿…æ‹…å¿ƒå› ä¸ºç³»ç»Ÿæ‰§è¡Œæ—¶çš„å¿…ç„¶æ—¶é—´æŸè€—å¯¼è‡´é˜ˆå€¼$delta$åå°è€Œå¼•èµ·è§„åˆ™å†²çªæ²¡æœ‰è¢«ç›‘æµ‹å‡ºï¼Œå› ä¸ºç³»ç»Ÿä¸­çš„æ—¶é—´æŸè€—æžä½Žï¼Œé€šå¸¸ä¸ºæ¯«ç§’çº§åˆ«ã€‚
For example, if there are two rules, $R_1$ and $R_2$, that belong to the Trigger Conflict type of rule conflict in static detection, the assertion verification process is as follows: (1) First, observe the occurrence of $T_1$, $C_1$, and $A_1$, indicating that rule $R_1$ is triggered, passes the condition check, and successfully executes the expected action; (2) Second, observe the occurrence of $T_2$ and $C_2$, indicating that rule $R_2$ is triggered and passes the condition check, and the platform is about to execute the default action of $R_2$; (3) Observe that the time interval between the occurrence of events $A_1$ and $T_2$ is very short, less than the threshold $delta$. If all three steps are true, it can be considered that the execution of rule $R_1$ caused rule $R_2$ to be triggered and about to be executed. To prevent coincidences in the real world, i.e., to avoid misjudgments caused by other real-world reasons where rule $R_1$ and rule $R_2$ are triggered and executed in a short time under conditions that meet user expectations, the $delta$ here is usually set to a very small value, such as 0.1 seconds or even 0.01 seconds. There is no need to worry that the inevitable time loss during system execution will cause the threshold $delta$ to be too small and cause rule conflicts to not be detected, because the time loss in the system is extremely low, usually on the order of milliseconds.

\begin{table}[t]
	\caption{Assertion Verification Expression}
	\label{Assertion_Verification}
	\begin{adjustbox}{width=0.5\textwidth}
		\begin{tabular}[width=1\textwidth]{c|c|c}
			\hline
			\multicolumn{2}{c|}{\textbf{Classification}} & \textbf{Expression}\\
			\hline
			
			\multicolumn{2}{c|}{\textbf{Trigger Conflict}} &
			\makecell{
				$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(T_2), obs(C_2)$ \\
				$intime(A_1, T_2, delta)$}\\
			\hline
			
			\multirow{2}{*}{\textbf{Condition Conflict}} & Make Conditions Forbidden &
			\makecell{$obs(C_2)$ \\
				$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(\neg C_2)$ \\
				$intime(A_1, \neg C_2, delta)$} \\
			\cline{2-3}
			& Make Conditions Satisfied &
			\makecell{$obs(\neg C_2)$ \\
				$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(C_2)$\\
				$intime(A_1, C_2, delta)$ }\\
			\hline
			
			\multicolumn{2}{c|}{\textbf{Action Conflict}} &
			\makecell{
				$obs(T_1), obs(C_1), obs(A_1)$ 
				\\ $obs(T_2), obs(C_2)$}\\
			\hline
			
			\multicolumn{2}{c|}{\textbf{Indirect Trigger Conflict}} &
			\makecell{$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(T_2), obs(C_2)$} \\
			\hline
			
			\multirow{2}{*}{\textbf{Indirect Condition Conflict}} & Make Conditions Forbidden &
			\makecell{$obs(C_2)$ \\
				$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(\neg C_2)$  \\
				$intime(A_1, \neg C_2, delta)$ }\\
			\cline{2-3}
			& Make Conditions Satisfied &
			\makecell{$obs(\neg C_2)$ \\
				$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(C_2)$ \\
				$intime(A_1,  C_2, delta)$ }\\
			\hline
			
			\multicolumn{2}{c|}{\textbf{Indirect Action Conflict}}&
			\makecell{$obs(T_1), obs(C_1), obs(A_1)$ \\
				$obs(T_2), obs(C_2)$} \\
			\hline
			
		\end{tabular}
	\end{adjustbox}
\end{table}

% å½“æ–­è¨€æ£€æµ‹ç»“æžœè¡¨æ˜Žå½“å‰å³å°†å‘ç”ŸæŸä¸€ç±»åž‹çš„è§„åˆ™å†²çªæ—¶ï¼Œç³»ç»Ÿç«‹å³æ‰§è¡Œç›¸åº”çš„å†²çªå¤„ç†ç­–ç•¥ã€‚å…·ä½“æ‰§è¡Œæ–¹å¼ä¸ºï¼šåŸºäºŽé™æ€æ£€æµ‹ä¸­çš„Rule Conflict Resolution Strategyï¼Œç³»ç»Ÿæ£€ç´¢è§„åˆ™å†²çªå¯¹åº”çš„å†²çªå¤„ç†ç­–ç•¥ï¼Œç”Ÿæˆå…·ä½“çš„æ‰§è¡Œå‘½ä»¤ï¼Œé€šè¿‡Communication Proxy moduleäº¤ä»˜ç»™è¿è¡ŒæŽ§åˆ¶å™¨æ¨¡å—ã€‚è¿è¡ŒæŽ§åˆ¶å™¨æ¨¡å—æ‹¦æˆªåŽŸæœ‰çš„è§„åˆ™è§¦å‘æ‰§è¡Œé€»è¾‘ï¼ˆå³è§¦å‘ã€æ¡ä»¶æ£€æµ‹ä¸ŽåŠ¨ä½œæ‰§è¡Œï¼‰ï¼Œå¹¶å¼ºåˆ¶æ‰§è¡Œå¯¹åº”çš„å†²çªå¤„ç†ç­–ç•¥å¯¹åº”çš„åŠ¨ä½œï¼Œä»Žè€Œå®žçŽ°åœ¨è§„åˆ™å†²çœŸå®žå‘ç”Ÿå‰ï¼Œæ£€æµ‹åˆ°è§„åˆ™å†²çªå¹¶è¿›è¡Œå†²çªå¤„ç†ã€‚
When the assertion verification result indicates that a certain type of rule conflict is about to occur, the system immediately executes the corresponding conflict resolution strategy. The specific execution method is as follows: Based on the Rule Conflict Resolution Strategy in static detection, the system retrieves the conflict resolution strategy corresponding to the rule conflict, generates specific execution commands, and delivers them to the runtime controller module through the Communication Proxy module. The runtime controller module intercepts the original rule trigger execution logic (i.e., trigger, condition detection, and action execution) and forcibly executes the action corresponding to the corresponding conflict resolution strategy, thereby achieving the detection of rule conflicts and conflict resolution before the rule actually occurs.
\subsubsection{Runtime Controller}
%è¿è¡ŒæŽ§åˆ¶å™¨æ¨¡å—åœ¨Dynamic Detection and Conflict Resolutionä¸­èµ·åˆ°äº†è‡³å…³é‡è¦çš„ä½œç”¨ã€‚
Runtime controller module plays a crucial role in Dynamic Detection and Conflict Resolution.

%åœ¨è§„åˆ™å†²çªçš„åŠ¨æ€æ£€æµ‹è¿‡ç¨‹ä¸­ï¼Œè¿è¡ŒæŽ§åˆ¶å™¨æ¨¡å—ä¸Žè§„åˆ™äº‹ä»¶ç›‘å¬æ¨¡å—äº¤äº’ï¼Œåœ¨è§„åˆ™çš„æ¡ä»¶æ£€æŸ¥å‰åŽè¿›è¡Œç›‘å¬ï¼Œä¿è¯äº†ä¸¤ç§ç‰¹æ®Šæƒ…å†µï¼šï¼ˆ1ï¼‰ä¸€æ¡åŽŸæœ¬æ¡ä»¶ä¸é€šè¿‡çš„è§„åˆ™ï¼Œå› ä¸ºè§„åˆ™äº¤äº’å¯¼è‡´æ¡ä»¶é€šè¿‡ï¼Œå¹¶è¢«æˆåŠŸè§¦å‘ï¼›ï¼ˆ2ï¼‰åŽŸæœ¬æ¡ä»¶æ£€æµ‹é€šè¿‡çš„è§„åˆ™ï¼Œå› ä¸ºè§„åˆ™äº¤äº’å¯¼è‡´æ¡ä»¶ä¸é€šè¿‡ï¼Œå¹¶è¢«æˆåŠŸè§¦å‘ã€‚è¿è¡ŒæŽ§åˆ¶å™¨æ¨¡å—ä¸Žæ–­è¨€æ£€æµ‹æ¨¡å—äº¤äº’ï¼Œå…¶æ ¸å¿ƒåŠŸèƒ½åŒ…å«ä¸¤æ¡é€šä¿¡å‡½æ•°ï¼šï¼ˆ1ï¼‰get_entity_stateç”¨äºŽèŽ·å–å®žä½“çŠ¶æ€ï¼Œä»Žè€Œè¯»å–è®¾å¤‡ä¸Žè§„åˆ™çš„å½“å‰çŠ¶æ€ä¸ŽåŽ†å²çŠ¶æ€å˜åŒ–ä¿¡æ¯ï¼Œä»Žè€Œå¸®åŠ©æ–­è¨€æ£€æµ‹æ¨¡å—èŽ·å–æ‰€æœ‰éªŒè¯éœ€è¦çš„ä¿¡æ¯ã€‚ï¼ˆ2ï¼‰time_nowç”¨æˆ·èŽ·å–ç³»ç»Ÿå½“å‰äº‹ä»¶ï¼Œé¿å…å› ä¸ºç³»ç»Ÿæ—¶é—´ä¸Žå®žé™…æ—¶é—´åå·®å¯¼è‡´æ£€æµ‹ä¸Žå¤„ç†é”™è¯¯ã€‚
In the dynamic detection of rule conflicts, the runtime controller module interacts with the rule event listening module to listen before and after the condition check of the rules, ensuring two special cases: (1) a rule that originally did not pass the condition can pass the condition due to rule interaction and be successfully triggered; (2) a rule that originally passed the condition check can fail the condition due to rule interaction and be successfully triggered. The runtime controller module interacts with the assertion verification module, and its core functions include two communication functions: (1) \texttt{get\_entity\_state} is used to obtain the entity state, so as to read the current state and historical state change information of the device and the rule, so as to help the assertion verification module obtain all the information needed for verification. (2) \texttt{time\_now} is used to obtain the current event of the system, so as to avoid detection and processing errors caused by the deviation between the system time and the actual time.

%åœ¨è§„åˆ™å†²çªçš„å¤„ç†è¿‡ç¨‹ä¸­ï¼Œè¿è¡ŒæŽ§åˆ¶å™¨æ¨¡å—ä¸Žè§„åˆ™å‘½ä»¤ç”Ÿæˆæ¨¡å—äº¤äº’ï¼Œåœ¨è§„åˆ™çš„æ¡ä»¶æ£€æŸ¥å‰åŽè¿›è¡Œæ’å…¥ï¼Œä¿è¯äº†ä¸¤ç§ç‰¹æ®Šæƒ…å†µï¼šï¼ˆ1ï¼‰ä¸€æ¡åŽŸæœ¬æ¡ä»¶ä¸é€šè¿‡çš„è§„åˆ™ï¼Œå› ä¸ºè§„åˆ™äº¤äº’å¯¼è‡´æ¡ä»¶é€šè¿‡ï¼Œå¹¶è¢«æˆåŠŸè§¦å‘ï¼›ï¼ˆ2ï¼‰åŽŸæœ¬æ¡ä»¶æ£€æµ‹é€šè¿‡çš„è§„åˆ™ï¼Œå› ä¸ºè§„åˆ™äº¤äº’å¯¼è‡´æ¡ä»¶ä¸é€šè¿‡ï¼Œå¹¶è¢«æˆåŠŸè§¦å‘ã€‚å…¶æ ¸å¿ƒåŠŸèƒ½ä¸ºæ‹¦æˆªå½“å‰è§„åˆ™çš„æ‰§è¡ŒåŠ¨ä½œå¹¶æ‰§è¡Œä»Žå‘½ä»¤ç”Ÿæˆæ¨¡å—ç”Ÿæˆçš„æŒ‡ä»¤ï¼Œå¦‚å¼ºåˆ¶æ‰§è¡Œå½“å‰æ¡ä»¶ä¸é€šè¿‡çš„è§„åˆ™ï¼Œå¼ºåˆ¶æ‰§è¡ŒæŸæ¡è§„åˆ™çš„æ‰§è¡ŒåŠ¨ä½œç­‰ç­‰ã€‚
In the process of handling rule conflicts, the runtime controller module interacts with the rule command generation module to insert code before and after the rule's condition check. This ensures two special cases: (1) a rule that originally failed the condition check can pass the condition and be successfully triggered due to rule interaction; (2) a rule that originally passed the condition check can fail the condition and still be successfully triggered due to rule interaction. Its core function is to intercept the execution action of the current rule and execute the instructions generated from the command generation module, such as forcibly executing the current rule with a failed condition, forcibly executing the execution action of a certain rule, and so on.